
<!DOCTYPE html>
<html lang="zh-cn,en,default">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Salmons&#39;s Pool">
    <title>理解OC运行时 - Salmons&#39;s Pool</title>
    <meta name="author" content="Salmons">
    
    
        <link rel="icon" href="http://salmons.info/assets/images/favicon.ico">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Salmons","sameAs":[],"image":"favicon.ico"},"articleBody":"一直对runtime很感兴趣，我猜是因为我是从C转过来的，有一定的情结！很多内容都是在我看这两本书的时候学到的，在这里做一下总结和心得😁。\n\n\n《Objective-C高级编程 iOS与OS X多线程和内存管理》 \n\n\n《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》\n简介Objective-C是基于C语言加入了面向对象特性和消息转发机制的动态语言，这意味着它不仅需要一个编译器，还需要Runtime系统来动态创建类和对象，进行消息发送和转发。\nRuntime又叫运行时，是一套底层的C 语言 API，是 iOS 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。\nC语言中，在编译期，函数的调用就会决定调用哪个函数。而OC的函数，属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。\n在Objective-C中，使用[receiver message]语法并不会马上执行receiver对象的message方法的代码，而是向receiver发送一条message消息，这条消息可能由receiver来处理，也可能由转发给其他对象来处理，也有可能假装没有接收到这条消息而没有处理。其实[receiver message]被编译器转化为:\nid objc_msgSend ( id self, SEL op, ... );\n名词解释NSObject、id每当你coding的时候，有没有发现你创建的所有的类到最后都是以NSObject为基类，不相信的话就按住command键，一步一步的点，点到不能点！（NSProxy几个特殊的除外），然后我们来了解一下NSObject。\nApple维护的一份运行时源码: objc4-680\n为了方便，我把源码都贴在一起了，看几个结构体的定义：\n12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct objc_class *Class;//objc_object这是我们常用的id类型，指向的类型不局限于NSObject，譬如NSProxytypedef struct objc_object *id;//NSObject * 就是 NSObject类型的指针了，它范围较小。@interface NSObject &lt;NSObject&gt; &#123;    Class isa  OBJC_ISA_AVAILABILITY;&#125;@interface Object &#123;     Class isa; &#125;@interface NSObject &lt;NSObject&gt; &#123;    Class isa  OBJC_ISA_AVAILABILITY;&#125;struct objc_object &#123;private:\t //你会发现isa_t是个union    isa_t isa;&#125;struct objc_class : objc_object &#123;    // Class ISA;    Class superclass;    cache_t cache;             // formerly cache pointer and vtable    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags&#125;typedef struct objc_object &#123;    Class isa;&#125; *id;union isa_t &#123;    isa_t() &#123; &#125;    isa_t(uintptr_t value) : bits(value) &#123; &#125;    Class cls;    uintptr_t bits;&#125;\n由此可见struct objc_class : objc_object objc_class继承于objc_object\nobjc_class当然也会包含相同的isa结构体，Class是objc_class` typedef过来的，又有着继承关系。所以Class`本身也是个对象。\nobjc_class中其他成员：看名字理解，父类superclass，方法缓存cache，最后一个不容易看，我先说下是当前类的实例方法的一个集合。\nisa先说 isa表示一个Class对象的Class，也就是Meta Class。在面向对象设计中，一切都是对象，Class在设计中本身也是一个对象。\n当一个对象的实例方法被调用的时候，就是通过isa找到相应的类，然后在该类的class_data_bits_t（上文中objc_class的成员）中去查找方法。class_data_bits_t是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。\n如果是类方法呢？当然也是通过isa了。\n123`对象的实例方法` —— &gt;  `isa` —— &gt; `对象所属类``类方法` —— &gt; `isa` —— &gt; `❓`\n上面说了类也是个对象。那就让isa在类对象所属的类中找。我们叫它猿类，不好意思打错了，元类Meta Class。\n下图很好解释了对象，类，元类之间的关系。 \n\n解释一下这个图： 实线是super_class指针，虚线是isa指针。\n\nRoot Class是NSObject， NSObject是没有超类的，所以Root class(class)的superclass指向nil。\n每个Class都有一个isa指针指向唯一的Meta class\nRoot class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路。\n每个Meta class的isa指针都指向Root class (meta)。\n\nisa的类型是isa_t。 源码isa_t是个联合\n1234567union isa_t &#123;    isa_t() &#123; &#125;    isa_t(uintptr_t value) : bits(value) &#123; &#125;    Class cls;    uintptr_t bits;&#125;\n对于isa_t的深入了解，我也不是很懂！抱歉哈🐶\n懂了上图和元类的概念就可以了。\n隐藏参数self和_cmd当[receiver message]调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数self和_cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。至于对于self的描述，上面已经解释非常清楚了，下面我们重点讲解_cmd。\n_cmd表示当前调用方法，其实它就是一个方法选择器SEL（下文提到）。一般用于判断方法名或在Associated Objects中唯一标识键名，后面在Associated Objects会讲到。\nself 和 superself表示当前这个类的对象，而super是一个编译器标示符，和self指向同一个消息接受者。\n譬如[self class]和[super class]，接受消息者都是当前这个类的对象，但super与self不同的是，self调用class方法时，是在子类中查找方法，而super调用class方法时，是在父类中查找方法。\n又譬如当调用[self class]方法时，会转化为objc_msgSend函数，这个函数定义如下：\nid objc_msgSend(id self, SEL op, ...)\n这时会从当前类的方法列表中查找，如果没有，就到父类查找，还是没有，最后在NSObject类查找到。我们可以从NSObject.m文件中看到- (Class)class的实现：\n123- (Class)class &#123;    return object_getClass(self);&#125;\n又譬如当调用[super class]方法时，会转化为objc_msgSendSuper，这个函数定义如下：\nid objc_msgSendSuper(struct objc_super *super, SEL op, ...)\nobjc_msgSendSuper函数第一个参数super的数据类型是一个指向objc_super的结构体，从message.h文件中查看它的定义：\n123456789101112131415/// Specifies the superclass of an instance. struct objc_super &#123;    /// Specifies an instance of a class.    __unsafe_unretained id receiver;    /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__    /* For compatibility with old objc-runtime.h header */    __unsafe_unretained Class class;#else    __unsafe_unretained Class super_class;#endif    /* super_class is the first class to search */&#125;;#endif\n结构体包含两个成员，第一个是receiver，表示某个类的实例。第二个是super_class表示当前类的父类。\n这时首先会构造出objc_super结构体，这个结构体第一个成员是self，第二个成员是(id)class_getSuperclass(objc_getClass(&quot;Class&quot;))，实际上该函数会输出SuperClass。然后在父类查找class方法，查找不到，最后在NSObject查到。此时，内部使用objc_msgSend(objc_super-&gt;receiver, @selector(class))去调用，与[self class]调用相同，所以结果还是当前类。\nIvarIvar表示类中的实例变量，在runtime.h文件中找到它的定义：\n1234567891011/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar;struct objc_ivar &#123;    char *ivar_name                                          OBJC2_UNAVAILABLE;    char *ivar_type                                          OBJC2_UNAVAILABLE;    int ivar_offset                                          OBJC2_UNAVAILABLE;#ifdef __LP64__    int space                                                OBJC2_UNAVAILABLE;#endif&#125;\nIvar其实就是一个指向objc_ivar结构体指针，它包含了变量名(ivar_name)、变量类型(ivar_type)等信息。\nSELSEL称方法选择器\n通俗话来讲，isa指针指向的类的结构体中有这样一张SEL和IMP对应 的Dispatch table。你找到了SEL，最后还是要通过这个table找到IMP。SEL只是一个方法编号，并不是真正的方法实现地址。\nSEL要说的一点是，如果类不同，但是有相同的方法，他们对应的方法选择器是相同的，即使参数的类型不同，他们对应的方法选择器也是相同的，所以Objective-C不支持函数重载，有关什么是函数重载可以了解下C++\n接受者receiver收到对应的selector，如果有不能执行这个方法的情况，这条message要被转发，或者利用runtime动态添加这个方法的实现来正常执行。如果正常执行或者转发都失败。程序会crash\n所以OC这门运行时语言在编译期只确定了发消息，接受者如何响应或者处理消息是在运行时runtime决定，所以和C语言不同，不声明方法，程序编译也不会报错。\nIMPIMP本质上就是一个函数指针，指向方法的实现，在objc.h找到它的定义：\n123456/// A pointer to the function of a method implementation. #if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ ); #elsetypedef id (*IMP)(id, SEL, ...); #endif\n当你向某个对象发送一条信息，可以由这个函数指针来指定方法的实现，它最终就会执行那段代码，这样可以绕开消息传递阶段而去执行另一个方法实现。\n说句大白话，拿到了IMP，才能像使用C语言函数指针一样肆无忌惮。\nMethodMethod表示类中的某个方法，在runtime.h文件中找到它的定义：\n12345678/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;struct objc_method &#123;    SEL method_name                                          OBJC2_UNAVAILABLE;    char *method_types                                       OBJC2_UNAVAILABLE;    IMP method_imp                                           OBJC2_UNAVAILABLE;&#125;\n其实Method就是一个指向objc_method结构体指针，它存储了方法名(method_name)、方法类型(method_types)和方法实现(method_imp)等信息。\n大白话就是：Method表示一种类型，这种类型与SEL和实现IMP相关。\nCacheCache主要用来缓存，那它缓存什么呢？我们先在runtime.h文件看看它的定义：\n1234567typedef struct objc_cache *Cache                             OBJC2_UNAVAILABLE;struct objc_cache &#123;    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;    unsigned int occupied                                    OBJC2_UNAVAILABLE;    Method buckets[1]                                        OBJC2_UNAVAILABLE;&#125;;\nCache其实就是一个存储Method的链表，主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。\n关于 SEL, IMP, Method的理解，理解的不好的话，可以看看这篇文章http://blog.csdn.net/fengsh998/article/details/8614486\nRuntime原理objc_msgSend函数是如何发送消息的\n首先根据receiver对象的isa指针获取它对应的class\n优先在class的cache查找message方法，如果找不到，再到methodLists查找\n如果没有在class找到，再到super_class查找\n一旦找到message这个方法，就执行它实现的IMP。缓存到cache里面，以便下次使用\n\n消息发送和转发[receiver message]调用方法时，如果在message方法在receiver对象的类继承体系中没有找到方法，那怎么办？一般情况下，程序在运行时就会Crash掉，抛出 unrecognized selector sent to …类似这样的异常信息。但在抛出异常之前，还有三次机会按以下顺序让你拯救程序。\nMethod Resolution首先OC在运行时调用+ resolveInstanceMethod:或+ resolveClassMethod:方法，让你添加方法的实现。如果你添加方法并返回YES，那系统在运行时就会重新启动一次消息发送的过程。\n12345@interface Message : NSObject- (void)sendMessage:(NSString *)word;@end\n12345678@implementation Message- (void)sendMessage:(NSString *)word&#123;    NSLog(@&quot;normal way : send message = %@&quot;, word);&#125;@end\n如果我在viewDidLoad方法中创建Message对象并调用sendMessage方法：\n123456- (void)viewDidLoad &#123;    [super viewDidLoad];    Message *message = [Message new];    [message sendMessage:@&quot;SwifterFit&quot;];&#125;\n输出：send message = SwifterFit\n但现在我将原来sendMessage方法实现给注释掉，覆盖resolveInstanceMethod方法：\n12345678910111213#pragma mark - Method Resolution/// override resolveInstanceMethod or resolveClassMethod for changing sendMessage method implementation+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;    if (sel == @selector(sendMessage:)) &#123;        class_addMethod([self class], sel, imp_implementationWithBlock(^(id self, NSString *word) &#123;            NSLog(@&quot;method resolution way : send message = %@&quot;, word);        &#125;), &quot;v@*&quot;);    &#125;    return YES;&#125;\n输出：send message = SwifterFit\n如果resolveInstanceMethod方法返回NO，运行时就跳转到下一步：消息转发Message Forwarding\nFast Forwarding如果目标对象实现- forwardingTargetForSelector:方法，系统就会在运行时调用这个方法，只要这个方法返回的不是nil或self，也会重启消息发送的过程，把这消息转发给其他对象来处理。否则，就会继续Normal Fowarding。\n继续上面Message类的例子，将sendMessage和resolveInstanceMethod方法注释掉，然后添加forwardingTargetForSelector方法的实现：\n将sendMessage和resolveInstanceMethod方法注释掉，然后添加forwardingTargetForSelector方法的实现：\n123456789#pragma mark - Fast Forwarding- (id)forwardingTargetForSelector:(SEL)aSelector&#123;    if (aSelector == @selector(sendMessage:)) &#123;        return [MessageForwarding new];    &#125;    return nil;&#125;\n此时还缺一个转发消息的类MessageForwarding，这个类的设计与实现如下：\n12345@interface MessageForwarding : NSObject- (void)sendMessage:(NSString *)word;@end\n12345678@implementation MessageForwarding- (void)sendMessage:(NSString *)word&#123;    NSLog(@&quot;fast forwarding way : send message = %@&quot;, word);&#125;@end\n这里叫Fast，是因为这一步不会创建NSInvocation对象，但Normal Forwarding会创建它，所以相对于更快点。\nNormal Forwarding如果没有使用Fast Forwarding来消息转发，最后只有使用Normal Forwarding来进行消息转发。它首先调用methodSignatureForSelector:方法来获取函数的参数和返回值，如果返回为nil，程序会Crash掉，并抛出unrecognized selector sent to instance异常信息。如果返回一个函数签名，系统就会创建一个NSInvocation对象并调用-forwardInvocation:方法。\n继续前面的例子，将forwardingTargetForSelector方法注释掉，添加methodSignatureForSelector和forwardInvocation方法的实现：\n1234567891011121314151617181920#pragma mark - Normal Forwarding- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;    NSMethodSignature *methodSignature = [super methodSignatureForSelector:aSelector];    if (!methodSignature) &#123;        methodSignature = [NSMethodSignature signatureWithObjCTypes:&quot;v@:*&quot;];    &#125;    return methodSignature;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;    MessageForwarding *messageForwarding = [MessageForwarding new];    if ([messageForwarding respondsToSelector:anInvocation.selector]) &#123;        [anInvocation invokeWithTarget:messageForwarding];    &#125;&#125;\nRuntime提供三种方式来将原来的方法实现代替掉，那该怎样选择它们呢？\n\nMethod Resolution：由于Method Resolution不能像消息转发那样可以交给其他对象来处理，所以只适用于在原来的类中代替掉。\nFast Forwarding：它可以将消息处理转发给其他对象，使用范围更广，不只是限于原来的对象。\nNormal Forwarding：它跟Fast Forwarding一样可以消息转发，但它能通过NSInvocation对象获取更多消息发送的信息，例如：target、selector、arguments和返回值等信息。\n\nRuntime应用为Category添加属性property\nAssociated Objects\n\n当想使用Category对已存在的类进行扩展时，一般只能添加实例方法或类方法，而不适合添加额外的属性。虽然可以在Category头文件中声明property属性，但在实现文件中编译器是无法synthesize任何实例变量和属性访问方法。这时需要自定义属性访问方法并且使用Associated Objects来给已存在的类Category添加自定义的属性。Associated Objects提供三个API来向对象添加、获取和删除关联值：\nvoid objc_setAssociatedObject (id object, const void *key, id value, objc_AssociationPolicy policy )id objc_getAssociatedObject (id object, const void *key )void objc_removeAssociatedObjects (id object )\n其中objc_AssociationPolicy是个枚举类型，它可以指定Objc内存管理的引用计数机制。\n1234567891011typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.                                             *   The association is not made atomically. */    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.                                             *   The association is not made atomically. */    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.                                            *   The association is made atomically. */    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.                                            *   The association is made atomically. */&#125;;\n下面有个关于NSObject+AssociatedObject Category添加属性associatedObject的示例代码:\n12345@interface NSObject (AssociatedObject)@property (strong, nonatomic) id associatedObject;@end\n12345678910111213@implementation NSObject (AssociatedObject)- (void)setAssociatedObject:(id)associatedObject&#123;    objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)associatedObject&#123;    return objc_getAssociatedObject(self, _cmd);&#125;@end\nAssociated Objects的key要求是唯一并且是常量，而SEL是满足这个要求的，所以上面的采用隐藏参数_cmd作为key。\nMethod Swizzling提到Objective-C 中的 Runtime，大多数人第一个想到的可能就是黑魔法Method Swizzling。毕竟这是Runtime里面很强大的一部分，它可以通过Runtime的API实现更改任意的方法，理论上可以在运行时通过类名/方法名hook到任何 OC方法，替换任何类的实现以及新增任意类。\n举的最多的例子应该就是埋点统计用户信息的例子。\n假设我们需要在页面上不同的地方统计用户信息，常见做法有两种：\n\n傻瓜式的在所有需要统计的页面都加上代码。这样做简单，但是重复的代码太多。\n把统计的代码写入基类中，比如说BaseViewController。这样虽然代码只需要写一次，但是UITableViewController，UICollectionViewcontroller都需要写一遍，这样重复的代码依旧不少。\n\n这时候我们就可以使用 Method Swizzling。\nMethod Swizzing是发生在运行时的，主要用于在运行时将两个Method进行交换，我们可以将Method Swizzling代码写到任何地方，但是只有在这段Method Swilzzling代码执行完毕之后互换才起作用。而且Method Swizzling也是iOS中AOP(Aspect-Oriented Programming)(面相方面编程)的一种实现方式，我们可以利用苹果这一特性来实现AOP编程。\nMethod Swizzling本质上就是对IMP和SEL进行交换。\n一般我们使用都是新建一个分类，在分类中进行Method Swizzling方法的交换。交换的代码模板如下：\n1234567891011121314151617181920212223242526272829303132#import &lt;objc/runtime.h&gt;@implementation UIViewController (Swizzling)+ (void)load &#123;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        Class class = [self class];        // When swizzling a class method, use the following:        // Class class = object_getClass((id)self);        SEL originalSelector = @selector(viewWillAppear:);        SEL swizzledSelector = @selector(xxx_viewWillAppear:);        Method originalMethod = class_getInstanceMethod(class, originalSelector);        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);        BOOL didAddMethod = class_addMethod(class,                                            originalSelector,                                            method_getImplementation(swizzledMethod),                                            method_getTypeEncoding(swizzledMethod));        if (didAddMethod) &#123;            class_replaceMethod(class,                                swizzledSelector,                                method_getImplementation(originalMethod),                                method_getTypeEncoding(originalMethod));        &#125; else &#123;            method_exchangeImplementations(originalMethod, swizzledMethod);        &#125;    &#125;);&#125;#pragma mark - Method Swizzling- (void)xxx_viewWillAppear:(BOOL)animated &#123;    [self xxx_viewWillAppear:animated];    NSLog(@&quot;viewWillAppear: %@&quot;, self);&#125;@end\nMethod Swizzling可以在运行时通过修改类的方法列表中selector对应的函数或者设置交换方法实现，来动态修改方法。可以重写某个方法而不用继承，同时还可以调用原先的实现。所以通常应用于在category中添加一个方法。\n注意点Swizzling应该总在+load中执行Objective-C在运行时会自动调用类的两个方法+load和+initialize。+load会在类初始加载时调用， +initialize方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize方法是永远不会被调用的。所以Swizzling要是写在+initialize方法中，是有可能永远都不被执行。\n和+initialize比较+load能保证在类的初始化过程中被加载。\nSwizzling应该总是在dispatch_once中执行Swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为Method Swizzling的最佳实践。\n这里有一个很容易犯的错误，那就是继承中用了Swizzling。如果不写dispatch_once就会导致Swizzling失效！\n举个例子，比如同时对NSArray和NSMutableArray中的objectAtIndex:方法都进行了Swizzling，这样可能会导致NSArray中的Swizzling失效的。\n可是为什么会这样呢？\n原因是，我们没有用dispatch_once控制Swizzling只执行一次。如果这段Swizzling被执行多次，经过多次的交换IMP和SEL之后，结果可能就是未交换之前的状态。\n比如说父类A的B方法和子类C的D方法进行交换，交换一次后，父类A持有D方法的IMP，子类C持有B方法的IMP，但是再次交换一次，就又还原了。父类A还是持有B方法的IMP，子类C还是持有D方法的IMP，这样就相当于咩有交换。可以看出，如果不写dispatch_once，偶数次交换以后，相当于没有交换，Swizzling失效！\nSwizzling在+load中执行时，不要调用[super load]原因同注意点二，如果是多继承，并且对同一个方法都进行了Swizzling，那么调用[super load]以后，父类的Swizzling就失效了。\n现在比较火的hotfix，JSPatch就是应用了OC的runtime特性实现js与OC互通来动态修改方法的实现。\n比较出名的以下是字典转模型的开眼框架都应用了runtime特性。\nApple的KVO 也使用了runtime的特性。\n\nMethod Swizzling就像一把瑞士小刀，如果使用得当，它会有效地解决问题。但使用不当，将带来很多麻烦。在stackoverflow上有人已经提出这样一个问题：What are the Dangers of Method Swizzling in Objective C?，它的危险性主要体现以下几个方面：\n\n\n\nMethod swizzling is not atomic\nChanges behavior of un-owned code\nPossible naming conflicts\nSwizzling changes the method’s arguments\nThe order of swizzles matters\nDifficult to understand (looks recursive)\nDifficult to debug\n\n\n继续努力吧。加油！\n","dateCreated":"2016-03-08T13:37:09+08:00","dateModified":"2018-12-17T13:58:42+08:00","datePublished":"2016-03-08T13:37:09+08:00","description":"一直对runtime很感兴趣，我猜是因为我是从C转过来的，有一定的情结！很多内容都是在我看这两本书的时候","headline":"理解OC运行时","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://salmons.info/2016/03/08/Objective-C Runtime/"},"publisher":{"@type":"Organization","name":"Salmons","sameAs":[],"image":"favicon.ico","logo":{"@type":"ImageObject","url":"favicon.ico"}},"url":"http://salmons.info/2016/03/08/Objective-C Runtime/"}</script>
    <meta name="description" content="一直对runtime很感兴趣，我猜是因为我是从C转过来的，有一定的情结！很多内容都是在我看这两本书的时候">
<meta property="og:type" content="blog">
<meta property="og:title" content="理解OC运行时">
<meta property="og:url" content="http://salmons.info/2016/03/08/Objective-C Runtime/index.html">
<meta property="og:site_name" content="Salmons&#39;s Pool">
<meta property="og:description" content="一直对runtime很感兴趣，我猜是因为我是从C转过来的，有一定的情结！很多内容都是在我看这两本书的时候">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://oma38gsun.bkt.clouddn.com/meta-class.jpg">
<meta property="og:updated_time" content="2018-12-17T05:58:42.304Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="理解OC运行时">
<meta name="twitter:description" content="一直对runtime很感兴趣，我猜是因为我是从C转过来的，有一定的情结！很多内容都是在我看这两本书的时候">
<meta name="twitter:image" content="http://oma38gsun.bkt.clouddn.com/meta-class.jpg">
    
    
        
    
    
        <meta property="og:image" content="http://salmons.info/assets/images/favicon.ico"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Salmons&#39;s Pool</a>
    </div>
    
        
            <a class="header-right-icon " href="/">
        
        
            <i class="fa fa-home fa-lg"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/favicon.ico" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">Salmons</h4>
                
                    <h5 class="sidebar-profile-bio"><p>life begins at the end of your comfort zone</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="分类">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="标签">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/swifterfit" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://www.instagram.com/swifterfit/" target="_blank" rel="noopener" title="Instagram">
                    
                        <i class="sidebar-button-icon fab fa-instagram" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Instagram</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="mailto:swifterfit@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/atom.xml" title="RSS">
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            理解OC运行时
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2016-03-08T13:37:09+08:00">
	
		    3月 08, 2016
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/iOS/">iOS</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>一直对runtime很感兴趣，我猜是因为我是从<code>C</code>转过来的，有一定的情结！很多内容都是在我看这两本书的时候<br><a id="more"></a><br>学到的，在这里做一下总结和心得😁。</p>
<blockquote>
</blockquote>
<p><strong>《Objective-C高级编程 iOS与OS X多线程和内存管理》</strong> </p>
<blockquote>
</blockquote>
<p><strong>《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》</strong></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Objective-C</code>是基于<code>C</code>语言加入了面向对象特性和消息转发机制的动态语言，这意味着它不仅需要一个编译器，还需要Runtime系统来动态创建类和对象，进行消息发送和转发。</p>
<p><code>Runtime</code>又叫运行时，是一套底层的<code>C</code> 语言 API，是 <code>iOS</code> 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。</p>
<p><code>C</code>语言中，在<strong>编译期</strong>，函数的调用就会决定调用哪个函数。<br>而<code>OC</code>的函数，属于动态调用过程，在<strong>编译期</strong>并不能决定真正调用哪个函数，只有在真正<strong>运行时</strong>才会根据函数的名称找到对应的函数来调用。</p>
<p>在<code>Objective-C</code>中，使用<code>[receiver message]</code>语法并不会马上执行<code>receiver</code>对象的<code>message</code>方法的代码，而是向<code>receiver</code>发送一条<code>message</code>消息，这条消息可能由<code>receiver</code>来处理，也可能由转发给其他对象来处理，也有可能假装没有接收到这条消息而没有处理。其实<code>[receiver message]</code>被编译器转化为:</p>
<p><code>id objc_msgSend ( id self, SEL op, ... );</code></p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><h4 id="NSObject、id"><a href="#NSObject、id" class="headerlink" title="NSObject、id"></a>NSObject、id</h4><p>每当你<code>coding</code>的时候，有没有发现你创建的所有的类到最后都是以<code>NSObject</code>为基类，不相信的话就按住<code>command</code>键，一步一步的点，点到不能点！（<code>NSProxy</code>几个特殊的除外），然后我们来了解一下<code>NSObject</code>。</p>
<p><code>Apple</code>维护的一份运行时源码: <a href="http://opensource.apple.com//source/objc4/objc4-680/" target="_blank"><font color="blue"><u>objc4-680</u></font></a></p>
<p>为了方便，我把源码都贴在一起了，看几个结构体的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">//objc_object这是我们常用的id类型，指向的类型不局限于NSObject，譬如NSProxy</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">//NSObject * 就是 NSObject类型的指针了，它范围较小。</span><br><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface Object &#123; </span><br><span class="line">    Class isa; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	 //你会发现isa_t是个union</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125; *id;</span><br><span class="line"></span><br><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见<code>struct objc_class : objc_object</code> <code>objc_class</code>继承于<code>objc_object</code></p>
<p><code>objc_class</code>当然也会包含相同的<code>isa</code>结构体，<code>Class</code>是<code>objc_class`</code> typedef<code>过来的，又有着继承关系。所以</code>Class`本身也是个对象。</p>
<p><code>objc_class</code>中其他成员：看名字理解，父类<code>superclass</code>，方法缓存<code>cache</code>，最后一个不容易看，我先说下是当前类的实例方法的一个集合。</p>
<h4 id="isa"><a href="#isa" class="headerlink" title="isa"></a>isa</h4><p>先说 <code>isa</code>表示一个<code>Class</code>对象的<code>Class</code>，也就是<code>Meta Class</code>。在面向对象设计中，一切都是对象，<code>Class</code>在设计中本身也是一个对象。</p>
<p>当一个对象的实例方法被调用的时候，就是通过<code>isa</code>找到相应的类，然后在该类的<code>class_data_bits_t</code>（上文中<code>objc_class</code>的成员）中去查找方法。<code>class_data_bits_t</code>是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。</p>
<p>如果是类方法呢？当然也是通过<code>isa</code>了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`对象的实例方法` —— &gt;  `isa` —— &gt; `对象所属类`</span><br><span class="line"></span><br><span class="line">`类方法` —— &gt; `isa` —— &gt; `❓`</span><br></pre></td></tr></table></figure>
<p>上面说了类也是个对象。那就让<code>isa</code>在类对象所属的类中找。我们叫它猿类，不好意思打错了，元类<code>Meta Class</code>。</p>
<p>下图很好解释了对象，类，元类之间的关系。 </p>
<p><img src="http://oma38gsun.bkt.clouddn.com/meta-class.jpg" alt=""></p>
<p>解释一下这个图： 实线是<code>super_class</code>指针，虚线是<code>isa</code>指针。</p>
<ul>
<li><code>Root Class</code>是<code>NSObject</code>， <code>NSObject</code>是没有超类的，所以<code>Root class(class)</code>的<code>superclass</code>指向<code>nil</code>。</li>
<li>每个<code>Class</code>都有一个<code>isa</code>指针指向唯一的<code>Meta class</code></li>
<li><code>Root class(meta)</code>的<code>superclass</code>指向<code>Root class(class)</code>，也就是<code>NSObject</code>，形成一个回路。</li>
<li>每个<code>Meta class</code>的<code>isa</code>指针都指向<code>Root class (meta)</code>。</li>
</ul>
<p><code>isa</code>的类型是<code>isa_t</code>。 源码<code>isa_t</code>是个联合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对于<code>isa_t</code>的深入了解，我也不是很懂！抱歉哈🐶</strong></p>
<p>懂了上图和元类的概念就可以了。</p>
<h4 id="隐藏参数self和-cmd"><a href="#隐藏参数self和-cmd" class="headerlink" title="隐藏参数self和_cmd"></a>隐藏参数self和_cmd</h4><p>当<code>[receiver message]</code>调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数<code>self</code>和<code>_cmd</code>，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。至于对于<code>self</code>的描述，上面已经解释非常清楚了，下面我们重点讲解<code>_cmd</code>。</p>
<p><code>_cmd</code>表示当前调用方法，其实它就是一个方法选择器<code>SEL</code>（<em>下文提到</em>）。一般用于判断方法名或在<code>Associated Objects</code>中唯一标识键名，后面在<code>Associated Objects</code>会讲到。</p>
<h4 id="self-和-super"><a href="#self-和-super" class="headerlink" title="self 和 super"></a>self 和 super</h4><p><code>self</code>表示当前这个类的对象，而<code>super</code>是一个编译器标示符，和<code>self</code>指向同一个消息接受者。</p>
<p>譬如<code>[self class]</code>和<code>[super class]</code>，接受消息者都是当前这个类的对象，但<code>super</code>与<code>self</code>不同的是，<code>self</code>调用<code>class</code>方法时，是在子类中查找方法，而<code>super</code>调用<code>class</code>方法时，是在父类中查找方法。</p>
<p>又譬如当调用<code>[self class]</code>方法时，会转化为<code>objc_msgSend</code>函数，这个函数定义如下：</p>
<p><code>id objc_msgSend(id self, SEL op, ...)</code></p>
<p>这时会从当前类的方法列表中查找，如果没有，就到父类查找，还是没有，最后在<code>NSObject</code>类查找到。我们可以从<code>NSObject.m</code>文件中看到<code>- (Class)class</code>的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又譬如当调用<code>[super class]</code>方法时，会转化为<code>objc_msgSendSuper</code>，这个函数定义如下：</p>
<p><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</code></p>
<p><code>objc_msgSendSuper</code>函数第一个参数<code>super</code>的数据类型是一个指向<code>objc_super</code>的结构体，从<code>message.h</code>文件中查看它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/// Specifies the superclass of an instance. </span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    /// Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line"></span><br><span class="line">    /// Specifies the particular superclass of the instance to message. </span><br><span class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br><span class="line">    /* For compatibility with old objc-runtime.h header */</span><br><span class="line">    __unsafe_unretained Class class;</span><br><span class="line">#else</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">#endif</span><br><span class="line">    /* super_class is the first class to search */</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>结构体包含两个成员，第一个是<code>receiver</code>，表示某个类的实例。第二个是<code>super_class</code>表示当前类的父类。</p>
<p>这时首先会构造出<code>objc_super</code>结构体，这个结构体第一个成员是<code>self</code>，第二个成员是<code>(id)class_getSuperclass(objc_getClass(&quot;Class&quot;))</code>，实际上该函数会输出<code>SuperClass</code>。然后在父类查找<code>class</code>方法，查找不到，最后在<code>NSObject</code>查到。此时，内部使用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，与<code>[self class]</code>调用相同，所以结果还是当前类。</p>
<h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p><code>Ivar</code>表示类中的实例变量，在<code>runtime.h</code>文件中找到它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents an instance variable.</span><br><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line">struct objc_ivar &#123;</span><br><span class="line">    char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Ivar</code>其实就是一个指向<code>objc_ivar</code>结构体指针，它包含了变量名<code>(ivar_name)</code>、变量类型<code>(ivar_type)</code>等信息。</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p><code>SEL</code>称方法选择器</p>
<p>通俗话来讲，<code>isa</code>指针指向的类的结构体中有这样一张<code>SEL</code>和<code>IMP</code>对应 的Dispatch table。你找到了SEL，最后还是要通过这个table找到IMP。<code>SEL</code>只是一个方法编号，并不是真正的方法实现地址。</p>
<p><code>SEL</code>要说的一点是，如果类不同，但是有相同的方法，他们对应的方法选择器是相同的，即使参数的类型不同，他们对应的方法选择器也是相同的，所以<code>Objective-C</code>不支持函数重载，有关什么是函数重载可以了解下<code>C++</code></p>
<p>接受者<code>receiver</code>收到对应的<code>selector</code>，如果有不能执行这个方法的情况，这条<code>message</code>要被转发，或者利用<code>runtime</code>动态添加这个方法的实现来正常执行。如果正常执行或者转发都失败。程序会<code>crash</code></p>
<p>所以<code>OC</code>这门运行时语言在<strong>编译期</strong>只确定了发消息，接受者如何响应或者处理消息是在<strong>运行时</strong><code>runtime</code>决定，所以和<code>C</code>语言不同，不声明方法，程序编译也不会报错。</p>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p><code>IMP</code>本质上就是一个函数指针，指向方法的实现，在<code>objc.h</code>找到它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// A pointer to the function of a method implementation. </span><br><span class="line">#if !OBJC_OLD_DISPATCH_PROTOTYPES</span><br><span class="line">typedef void (*IMP)(void /* id, SEL, ... */ ); </span><br><span class="line">#else</span><br><span class="line">typedef id (*IMP)(id, SEL, ...); </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>当你向某个对象发送一条信息，可以由这个函数指针来指定方法的实现，它最终就会执行那段代码，这样可以绕开消息传递阶段而去执行另一个方法实现。</p>
<p>说句大白话，拿到了<code>IMP</code>，才能像使用<code>C</code>语言函数指针一样肆无忌惮。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p><code>Method</code>表示类中的某个方法，在runtime.h文件中找到它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method in a class definition.</span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实<code>Method</code>就是一个指向<code>objc_method</code>结构体指针，它存储了方法名<code>(method_name)</code>、方法类型<code>(method_types)</code>和方法实现<code>(method_imp)</code>等信息。</p>
<p>大白话就是：<code>Method</code>表示一种类型，这种类型与<code>SEL</code>和实现<code>IMP</code>相关。</p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p><code>Cache</code>主要用来缓存，那它缓存什么呢？我们先在<code>runtime.h</code>文件看看它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_cache *Cache                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">struct objc_cache &#123;</span><br><span class="line">    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;</span><br><span class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[1]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Cache</code>其实就是一个存储<code>Method</code>的链表，主要是为了优化方法调用的性能。当对象<code>receiver</code>调用方法<code>message</code>时，首先根据对象<code>receiver</code>的isa指针查找到它对应的类，然后在类的<code>methodLists</code>中搜索方法，如果没有找到，就使用<code>super_class</code>指针到父类中的<code>methodLists</code>查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用<code>Cache</code>来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到<code>methodLists</code>查找。</p>
<p>关于 <code>SEL</code>, <code>IMP</code>, <code>Method</code>的理解，理解的不好的话，可以看看这篇文章<a href="http://blog.csdn.net/fengsh998/article/details/8614486" target="_blank" rel="noopener">http://blog.csdn.net/fengsh998/article/details/8614486</a></p>
<h3 id="Runtime原理"><a href="#Runtime原理" class="headerlink" title="Runtime原理"></a>Runtime原理</h3><h4 id="objc-msgSend函数是如何发送消息的"><a href="#objc-msgSend函数是如何发送消息的" class="headerlink" title="objc_msgSend函数是如何发送消息的"></a>objc_msgSend函数是如何发送消息的</h4><ul>
<li>首先根据<code>receiver</code>对象的<code>isa</code>指针获取它对应的<code>class</code></li>
<li>优先在<code>class</code>的<code>cache</code>查找<code>message方</code>法，如果找不到，再到<code>methodLists</code>查找</li>
<li>如果没有在<code>class</code>找到，再到<code>super_class</code>查找</li>
<li>一旦找到<code>message</code>这个方法，就执行它实现的<code>IMP</code>。缓存到<code>cache</code>里面，以便下次使用</li>
</ul>
<h4 id="消息发送和转发"><a href="#消息发送和转发" class="headerlink" title="消息发送和转发"></a>消息发送和转发</h4><p><code>[receiver message]</code>调用方法时，如果在<code>message</code>方法在<code>receiver</code>对象的类继承体系中没有找到方法，那怎么办？一般情况下，程序在运行时就会Crash掉，抛出 <code>unrecognized selector sent to …</code>类似这样的异常信息。但在抛出异常之前，还有三次机会按以下顺序让你拯救程序。</p>
<h5 id="Method-Resolution"><a href="#Method-Resolution" class="headerlink" title="Method Resolution"></a>Method Resolution</h5><p>首先<code>OC</code>在运行时调用<code>+ resolveInstanceMethod:</code>或<code>+ resolveClassMethod:</code>方法，让你添加方法的实现。如果你添加方法并返回YES，那系统在运行时就会重新启动一次消息发送的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface Message : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage:(NSString *)word;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Message</span><br><span class="line"></span><br><span class="line">- (void)sendMessage:(NSString *)word</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;normal way : send message = %@&quot;, word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>如果我在<code>viewDidLoad</code>方法中创建<code>Message</code>对象并调用<code>sendMessage</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    Message *message = [Message new];</span><br><span class="line">    [message sendMessage:@&quot;SwifterFit&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：send message = SwifterFit</p>
<p>但现在我将原来<code>sendMessage</code>方法实现给注释掉，覆盖<code>resolveInstanceMethod</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Method Resolution</span><br><span class="line"></span><br><span class="line">/// override resolveInstanceMethod or resolveClassMethod for changing sendMessage method implementation</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    if (sel == @selector(sendMessage:)) &#123;</span><br><span class="line">        class_addMethod([self class], sel, imp_implementationWithBlock(^(id self, NSString *word) &#123;</span><br><span class="line">            NSLog(@&quot;method resolution way : send message = %@&quot;, word);</span><br><span class="line">        &#125;), &quot;v@*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：send message = SwifterFit</p>
<p>如果<code>resolveInstanceMethod</code>方法返回<code>NO</code>，运行时就跳转到下一步：消息转发<code>Message Forwarding</code></p>
<h5 id="Fast-Forwarding"><a href="#Fast-Forwarding" class="headerlink" title="Fast Forwarding"></a>Fast Forwarding</h5><p>如果目标对象实现<code>- forwardingTargetForSelector:</code>方法，系统就会在运行时调用这个方法，只要这个方法返回的不是<code>nil</code>或<code>self</code>，也会重启消息发送的过程，把这消息转发给其他对象来处理。否则，就会继续<code>Normal Fowarding</code>。</p>
<p>继续上面<code>Message</code>类的例子，将<code>sendMessage</code>和<code>resolveInstanceMethod</code>方法注释掉，然后添加<code>forwardingTargetForSelector</code>方法的实现：</p>
<p>将<code>sendMessage</code>和<code>resolveInstanceMethod</code>方法注释掉，然后添加<code>forwardingTargetForSelector</code>方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Fast Forwarding</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    if (aSelector == @selector(sendMessage:)) &#123;</span><br><span class="line">        return [MessageForwarding new];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时还缺一个转发消息的类<code>MessageForwarding</code>，这个类的设计与实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface MessageForwarding : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage:(NSString *)word;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation MessageForwarding</span><br><span class="line"></span><br><span class="line">- (void)sendMessage:(NSString *)word</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;fast forwarding way : send message = %@&quot;, word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这里叫<code>Fast</code>，是因为这一步不会创建<code>NSInvocation</code>对象，但<code>Normal Forwarding</code>会创建它，所以相对于更快点。</p>
<h5 id="Normal-Forwarding"><a href="#Normal-Forwarding" class="headerlink" title="Normal Forwarding"></a>Normal Forwarding</h5><p>如果没有使用<code>Fast Forwarding</code>来消息转发，最后只有使用<code>Normal Forwarding</code>来进行消息转发。它首先调用<code>methodSignatureForSelector:</code>方法来获取函数的参数和返回值，如果返回为<code>nil</code>，程序会Crash掉，并抛出<code>unrecognized selector sent to instance</code>异常信息。如果返回一个函数签名，系统就会创建一个<code>NSInvocation</code>对象并调用<code>-forwardInvocation:</code>方法。</p>
<p>继续前面的例子，将<code>forwardingTargetForSelector</code>方法注释掉，添加<code>methodSignatureForSelector和forwardInvocation</code>方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Normal Forwarding</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature *methodSignature = [super methodSignatureForSelector:aSelector];</span><br><span class="line"></span><br><span class="line">    if (!methodSignature) &#123;</span><br><span class="line">        methodSignature = [NSMethodSignature signatureWithObjCTypes:&quot;v@:*&quot;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return methodSignature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    MessageForwarding *messageForwarding = [MessageForwarding new];</span><br><span class="line"></span><br><span class="line">    if ([messageForwarding respondsToSelector:anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:messageForwarding];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runtime提供三种方式来将原来的方法实现代替掉，那该怎样选择它们呢？</p>
<ul>
<li><code>Method Resolution</code>：由于<code>Method Resolution</code>不能像消息转发那样可以交给其他对象来处理，所以只适用于在原来的类中代替掉。</li>
<li><code>Fast Forwarding</code>：它可以将消息处理转发给其他对象，使用范围更广，不只是限于原来的对象。</li>
<li><code>Normal Forwarding</code>：它跟<code>Fast Forwarding</code>一样可以消息转发，但它能通过<code>NSInvocation</code>对象获取更多消息发送的信息，例如：<code>target</code>、<code>selector</code>、<code>arguments</code>和返回值等信息。</li>
</ul>
<h3 id="Runtime应用"><a href="#Runtime应用" class="headerlink" title="Runtime应用"></a>Runtime应用</h3><h4 id="为Category添加属性property"><a href="#为Category添加属性property" class="headerlink" title="为Category添加属性property"></a>为Category添加属性property</h4><ul>
<li><code>Associated Objects</code></li>
</ul>
<p>当想使用<code>Category</code>对已存在的类进行扩展时，一般只能添加实例方法或类方法，而不适合添加额外的属性。虽然可以在<code>Category</code>头文件中声明<code>property</code>属性，但在实现文件中编译器是无法<code>synthesize</code>任何实例变量和属性访问方法。这时需要自定义属性访问方法并且使用<code>Associated Objects</code>来给已存在的类<code>Category</code>添加自定义的属性。<code>Associated Objects</code>提供三个API来向对象添加、获取和删除关联值：</p>
<p><code>void objc_setAssociatedObject (id object, const void *key, id value, objc_AssociationPolicy policy )</code><br><code>id objc_getAssociatedObject (id object, const void *key )</code><br><code>void objc_removeAssociatedObjects (id object )</code></p>
<p>其中<code>objc_AssociationPolicy</code>是个枚举类型，它可以指定Objc内存管理的引用计数机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. </span><br><span class="line">                                            *   The association is not made atomically. */</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied. </span><br><span class="line">                                            *   The association is not made atomically. */</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</span><br><span class="line">                                            *   The association is made atomically. */</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</span><br><span class="line">                                            *   The association is made atomically. */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面有个关于<code>NSObject+AssociatedObject</code> Category添加属性<code>associatedObject</code>的示例代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (AssociatedObject)</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) id associatedObject;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (AssociatedObject)</span><br><span class="line"></span><br><span class="line">- (void)setAssociatedObject:(id)associatedObject</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)associatedObject</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>Associated Objects</code>的key要求是唯一并且是常量，而<code>SEL</code>是满足这个要求的，所以上面的采用隐藏参数<code>_cmd</code>作为key。</p>
<h4 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h4><p>提到<code>Objective-C</code> 中的 <code>Runtime</code>，大多数人第一个想到的可能就是黑魔法<code>Method Swizzling</code>。毕竟这是<code>Runtime</code>里面很强大的一部分，它可以通过<code>Runtime</code>的API实现更改任意的方法，理论上可以在运行时通过类名/方法名<code>hook</code>到任何 <code>OC</code>方法，替换任何类的实现以及新增任意类。</p>
<p>举的最多的例子应该就是埋点统计用户信息的例子。</p>
<p>假设我们需要在页面上不同的地方统计用户信息，常见做法有两种：</p>
<ul>
<li>傻瓜式的在所有需要统计的页面都加上代码。这样做简单，但是重复的代码太多。</li>
<li>把统计的代码写入基类中，比如说<code>BaseViewController</code>。这样虽然代码只需要写一次，但是<code>UITableViewController</code>，<code>UICollectionViewcontroller</code>都需要写一遍，这样重复的代码依旧不少。</li>
</ul>
<p>这时候我们就可以使用 <code>Method Swizzling</code>。</p>
<p><code>Method Swizzing</code>是发生在<strong>运行时</strong>的，主要用于在<strong>运行时</strong>将两个<code>Method</code>进行交换，我们可以将<code>Method Swizzling</code>代码写到任何地方，但是只有在这段<code>Method Swilzzling</code>代码执行完毕之后互换才起作用。而且<code>Method Swizzling</code>也是<code>iOS</code>中<code>AOP</code>(Aspect-Oriented Programming)(<em>面相方面编程</em>)的一种实现方式，我们可以利用苹果这一特性来实现<code>AOP</code>编程。</p>
<p><code>Method Swizzling</code>本质上就是对<code>IMP</code>和<code>SEL</code>进行交换。</p>
<p>一般我们使用都是新建一个分类，在分类中进行<code>Method Swizzling</code>方法的交换。交换的代码模板如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">@implementation UIViewController (Swizzling)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = [self class];</span><br><span class="line">        // When swizzling a class method, use the following:</span><br><span class="line">        // Class class = object_getClass((id)self);</span><br><span class="line">        SEL originalSelector = @selector(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">        BOOL didAddMethod = class_addMethod(class,</span><br><span class="line">                                            originalSelector,</span><br><span class="line">                                            method_getImplementation(swizzledMethod),</span><br><span class="line">                                            method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        if (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(class,</span><br><span class="line">                                swizzledSelector,</span><br><span class="line">                                method_getImplementation(originalMethod),</span><br><span class="line">                                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - Method Swizzling</span><br><span class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [self xxx_viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>Method Swizzling</code>可以在运行时通过修改类的方法列表中<code>selector</code>对应的函数或者设置交换方法实现，来动态修改方法。可以重写某个方法而不用继承，同时还可以调用原先的实现。所以通常应用于在<code>category</code>中添加一个方法。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><h5 id="Swizzling应该总在-load中执行"><a href="#Swizzling应该总在-load中执行" class="headerlink" title="Swizzling应该总在+load中执行"></a><code>Swizzling</code>应该总在<code>+load</code>中执行</h5><p><code>Objective-C</code>在运行时会自动调用类的两个方法<code>+load</code>和<code>+initialize</code>。<code>+load</code>会在类初始加载时调用， <code>+initialize</code>方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 <code>+initialize</code>方法是永远不会被调用的。所以<code>Swizzling</code>要是写在<code>+initialize</code>方法中，是有可能永远都不被执行。</p>
<p>和<code>+initialize</code>比较<code>+load</code>能保证在类的初始化过程中被加载。</p>
<h5 id="Swizzling应该总是在dispatch-once中执行"><a href="#Swizzling应该总是在dispatch-once中执行" class="headerlink" title="Swizzling应该总是在dispatch_once中执行"></a><code>Swizzling</code>应该总是在<code>dispatch_once</code>中执行</h5><p>Swizzling会改变全局状态，所以在运行时采取一些预防措施，使用<code>dispatch_once</code>就能够确保代码不管有多少线程都只被执行一次。这将成为<code>Method Swizzling</code>的最佳实践。</p>
<p>这里有一个很容易犯的错误，那就是继承中用了<code>Swizzling</code>。如果不写<code>dispatch_once</code>就会导致<code>Swizzling</code>失效！</p>
<p>举个例子，比如同时对<code>NSArray</code>和<code>NSMutableArray</code>中的<code>objectAtIndex:</code>方法都进行了<code>Swizzling</code>，这样可能会导致<code>NSArray</code>中的<code>Swizzling</code>失效的。</p>
<p>可是为什么会这样呢？</p>
<p>原因是，我们没有用<code>dispatch_once</code>控制<code>Swizzling</code>只执行一次。如果这段<code>Swizzling</code>被执行多次，经过多次的交换<code>IMP</code>和<code>SEL</code>之后，结果可能就是未交换之前的状态。</p>
<p>比如说父类A的B方法和子类C的D方法进行交换，交换一次后，父类A持有D方法的<code>IMP</code>，子类C持有B方法的<code>IMP</code>，但是再次交换一次，就又还原了。父类A还是持有B方法的<code>IMP</code>，子类C还是持有D方法的<code>IMP</code>，这样就相当于咩有交换。可以看出，如果不写<code>dispatch_once</code>，偶数次交换以后，相当于没有交换，<code>Swizzling</code>失效！</p>
<h5 id="Swizzling在-load中执行时，不要调用-super-load"><a href="#Swizzling在-load中执行时，不要调用-super-load" class="headerlink" title="Swizzling在+load中执行时，不要调用[super load]"></a><code>Swizzling</code>在<code>+load</code>中执行时，不要调用<code>[super load]</code></h5><p>原因同注意点二，如果是多继承，并且对同一个方法都进行了<code>Swizzling</code>，那么调用<code>[super load]</code>以后，父类的<code>Swizzling</code>就失效了。</p>
<p>现在比较火的<code>hotfix</code>，<code>JSPatch</code>就是应用了<code>OC</code>的<code>runtime</code>特性实现<code>js</code>与<code>OC</code>互通来动态修改方法的实现。</p>
<p>比较出名的以下是字典转模型的开眼框架都应用了<code>runtime</code>特性。</p>
<p><code>Apple</code>的<code>KVO</code> 也使用了<code>runtime</code>的特性。</p>
<blockquote>
<p><code>Method Swizzling</code>就像一把瑞士小刀，如果使用得当，它会有效地解决问题。但使用不当，将带来很多麻烦。在<code>stackoverflow</code>上有人已经提出这样一个问题：<a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="noopener">What are the Dangers of Method Swizzling in Objective C?</a>，它的危险性主要体现以下几个方面：</p>
</blockquote>
<blockquote>
<ul>
<li>Method swizzling is not atomic</li>
<li>Changes behavior of un-owned code</li>
<li>Possible naming conflicts</li>
<li>Swizzling changes the method’s arguments</li>
<li>The order of swizzles matters</li>
<li>Difficult to understand (looks recursive)</li>
<li>Difficult to debug</li>
</ul>
</blockquote>
<p><strong>继续努力吧。加油！</strong></p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/03/09/lc707/" data-tooltip="707. Design Linked List" aria-label="上一篇: 707. Design Linked List">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/03/07/lc283/" data-tooltip="283. Move Zeroes" aria-label="下一篇: 283. Move Zeroes">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#disqus_thread">
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 Salmons. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/03/09/lc707/" data-tooltip="707. Design Linked List" aria-label="上一篇: 707. Design Linked List">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/03/07/lc283/" data-tooltip="283. Move Zeroes" aria-label="下一篇: 283. Move Zeroes">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#disqus_thread">
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="5">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/favicon.ico" alt="作者的图片">
        
            <h4 id="about-card-name">Salmons</h4>
        
            <div id="about-card-bio"><p>life begins at the end of your comfort zone</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>Bodybuilder, SE</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                China,Beijing
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    
        <script>
             var disqus_config = function () {
                 this.page.url = 'http://salmons.info/2016/03/08/Objective-C Runtime/';
                 
                    this.page.identifier = '2016/03/08/Objective-C Runtime/';
                 
             };
            (function() {
                var d = document, s = d.createElement('script');
                var disqus_shortname = 'Salmons';
                s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
    



    </body>
</html>

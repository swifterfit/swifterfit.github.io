<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Salmons&#39;s Pool</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://salmons.info/"/>
  <updated>2018-12-17T06:02:26.468Z</updated>
  <id>http://salmons.info/</id>
  
  <author>
    <name>Salmons</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>送给30岁的自己</title>
    <link href="http://salmons.info/2018/12/17/to30self/"/>
    <id>http://salmons.info/2018/12/17/to30self/</id>
    <published>2018-12-17T04:47:55.000Z</published>
    <updated>2018-12-17T06:02:26.468Z</updated>
    
    <content type="html"><![CDATA[<p>岁月太匆匆，在不经意间，第一批90后也很快就要步入30岁的行列。<br><a id="more"></a><br>有人说：<br>30岁是一个尴尬的阶段，我们大多事业还未有成，上有老下有小，成了一家人的顶梁柱。</p><p>30岁的年轻人，很容易患上“初老症”，梦想逐渐褪色，生活尽是苦涩。</p><p>如何让自己保持对生活的信心，不至于未老先衰，意志消退，其实是所有第一批90后要面对的难题。</p><p>时间可以改变我们的形象，但绝不会改变我们内心的渴望。</p><p>一旦进入了30岁，就不能孩子气了，下面这个10个道理，你必须要知道。</p><h4 id="01-一定要学会走自己的路"><a href="#01-一定要学会走自己的路" class="headerlink" title="01 一定要学会走自己的路"></a>01 一定要学会走自己的路</h4><p>进入30岁这个行列，别人的目光真的没那么重要了，他们的看法不会对我们的人生造成很大的影响，不会成为我们人生路上的绊脚石。</p><p>我们要学会走自己的路，让别人随便去说。</p><p>只要无愧于心，无愧于己就足够了。</p><p>我们不应该活在别人的眼光里，也不应该裹足于别人的唾沫里，更不应该活在别人给予的砝码之上。</p><p>一个人成熟的本质，就是了解到自己是人生唯一的责任人。</p><p>不要害怕别人看不起你，也不要和每个人都坦诚相待，为了自己的既定目标努力去奋斗就够了，只要努力了，我相信总有出头日。</p><h4 id="02-要学会懂自己"><a href="#02-要学会懂自己" class="headerlink" title="02 要学会懂自己"></a>02 要学会懂自己</h4><p>廖一梅曾说：<br>人这一辈子遇到爱，遇到性都不稀罕，稀罕的是遇到了解。</p><p>确实在生活中我们很难遇到懂自己的人。</p><p>我们小时候都曾与小伙伴山盟海誓，要一辈子做彼此的背膀。</p><p>可是，走着走着，许多曾经的好友都走散了，许多美好的回忆，只能在酒后谈起。</p><p>人这一辈子，遇到投机的人很容易，可是找一个能一直懂自己的人很难。</p><p>无论在婚姻里，还是职场里，我们可能一直找不到那个人，但也没必要遗憾，尽力就好。</p><p>有个人懂你是幸福的，如果没人懂那也是人生常态。你要学会自己懂自己，这世上没有任何人比你更爱自己。</p><h4 id="03-放宽心态，别斤斤计较"><a href="#03-放宽心态，别斤斤计较" class="headerlink" title="03 放宽心态，别斤斤计较"></a>03 放宽心态，别斤斤计较</h4><p>30岁，我们大多已经褪去年少轻狂，不再执迷于诗和远方。生活给予我们的更多是重复和苦涩。</p><p>油盐酱醋的生活里，琐事很多，可能经常会让我们毫无头绪，焦躁不安，慢慢变得怨天尤人，毫无乐趣。</p><p>其实，这只不过是自寻烦恼。</p><p>30岁了，要学会放下计较。那些鸡毛蒜皮的事情，真的没什么意思。计较的后果只会让自己更加生气，甚至会怀疑人生，还不如放宽心态，好好的生活。</p><p>生活越是向我们展现它无聊的一面，我们就越要保持平和的心态。就像电影《七宗罪》里最后说的：生活虽然不美好，但仍然值得去守护。</p><p>一个人的生活态度决定了他的生活质量，如果你不好好生活，那么一定会得到生活最残酷的惩罚。</p><h4 id="04-过好当下，别对最亲近的人发脾气"><a href="#04-过好当下，别对最亲近的人发脾气" class="headerlink" title="04 过好当下，别对最亲近的人发脾气"></a>04 过好当下，别对最亲近的人发脾气</h4><p>无论工作还是生活中，我们可能会有很多烦恼，但千万不要把这种烦恼发泄在最近亲的人身上。这样只会伤害他们，让他们也倍感压抑。</p><p>看过一个小故事：</p><p>有个人每次在单位里受了气，都不会直接回家，而是在一棵树底下呆一会，对着大树发泄自己的情绪，发泄完了，就收拾好心情回家。</p><p>这样的人，无论个人成就大还是小，都是一个有担当的人。因为家人是我们最后的港湾，也是我们活下去的动力。</p><p>《蝙蝠侠·黑暗骑士》里说：真正衡量英雄的标准，不在于他多有力量，而在于他能承受多少的苦难</p><p>外面的世界已经充满刀枪剑戟，让家人舒心和快乐，就是最好的英雄主义。</p><p>其实，生活真的很幸福，是我们要求太多了，当你能珍惜眼前的生活时，你定会发现这份生活是多么的美好。</p><h4 id="05-一定要学会珍惜友情"><a href="#05-一定要学会珍惜友情" class="headerlink" title="05 一定要学会珍惜友情"></a>05 一定要学会珍惜友情</h4><p>30岁以后，我们终于领悟到朋友的重要性。</p><p>马克思说：人是社会关系的总和。<br>有人说：多一个朋友多一条路。</p><p>朋友是资源，但更要的是，朋友是我们生活在这个残酷世界的需要。</p><p>没有朋友的孤家寡人，永远不可成大器，千金散去，还复来，朋友走了，就不会回来了。</p><p>当然没必要把时间花在酒肉朋友身上，因为他们不值得我们交往，我们需要的是彼此坦诚相待的好兄弟，朋友不要求多，而在于精，真心的有一两个就够了。</p><h4 id="06-一定要学会体谅父母"><a href="#06-一定要学会体谅父母" class="headerlink" title="06 一定要学会体谅父母"></a>06 一定要学会体谅父母</h4><p>生活中，我们经常会嫌弃父母唠叨，觉得他们根本不懂我们的生活，可你要知道父母都是为了我们好，当我们为人父母了，才懂得这份唠叨里藏着满满的爱。</p><p>30多岁了，千万别再嫌他们唠叨，我们和父母之间的缘分也越来越浅了，很可能一转身就再也不想见了，学会体谅父母，多花一些时间陪他们。</p><p>在父母的眼里我们永远都是孩子，我们长大了，他们也真的老了，现在我们得多哄他们开心了，多给他们打电话，这样他们才会安心。</p><h4 id="07-爱自己的工作，爱自己的身体"><a href="#07-爱自己的工作，爱自己的身体" class="headerlink" title="07 爱自己的工作，爱自己的身体"></a>07 爱自己的工作，爱自己的身体</h4><p>人一定要学会独立自主，尤其到了30岁这个行列。有些人结婚后，就不想工作了，想呆在家里过衣食无忧的生活。</p><p>无论男女都要有自己的一份工作，这是你人生的意义。</p><p>这份工作可能不会给你带来很多金钱上的收获，但却能让你获得成长，只要能让你的人生得到淬炼，这就足够了。</p><p>30多岁，真的是一个很尴尬的阶段，这个阶段我们压力很大，你可千万不要忘了爱自己，我们是家里的顶梁柱，如果没有我们，那么这个家就彻底完蛋了，一定要学会爱惜自己的身体。</p><p>因为这才是你革命的本钱，能不熬夜就别熬夜了，能对自己好一点就对自己好一点。</p><p>只有我们在，那么这个家才不会垮掉！一家老小才会生活在幸福之中。</p><h4 id="08不要攀比，更不要爱慕虚荣"><a href="#08不要攀比，更不要爱慕虚荣" class="headerlink" title="08不要攀比，更不要爱慕虚荣"></a>08不要攀比，更不要爱慕虚荣</h4><p>20多岁，我们喜欢攀比，喜欢好手机，喜欢好车，因为攀比我们成了月光族。</p><p>30多岁你需要活得成熟一些，所有的东西都是过眼云烟，真实地活着才是最重要的。</p><p>我们没必要追求大房子，追求豪车，你要知道，房子再大，你需要的不过是一张能够安然入睡的床，车子再好不过也是用来代步。</p><p>我们完全没必要羡慕别人一身名牌，不要羡慕她们奢侈的包包，因为这些都是身外之物，30多岁活得快乐才最重要的。</p><p>如果一个人把心思一直放在盲目攀比上，那么他的生活绝对不会幸福。</p><h4 id="09-三观不同不必强融"><a href="#09-三观不同不必强融" class="headerlink" title="09 三观不同不必强融"></a>09 三观不同不必强融</h4><p>萧伯纳说过：<br>自我控制是最强者的本能。</p><p>生活中我们会和很多人的三观不一样，既然不一样，那么就不要试图说服对方，伤了自己也伤了别人。</p><p>对待事情，每个人都有自己的看法，如果是对的你就选择坚持，要是不对的就学会改正。</p><p>更不要跟强词夺理的人交谈，因为这只会浪费你大量的时间，你的世界他们根本不懂。</p><p>30多岁了，就要活得通透了，当在生活中遭受到不被理解时，没必要急着去争个输赢。时间自然会给你最好的答案。</p><h4 id="10-学会理解和包容"><a href="#10-学会理解和包容" class="headerlink" title="10 学会理解和包容"></a>10 学会理解和包容</h4><p>人非圣贤孰能无过，所以对身边的人和事要学会包容，千万不要揪着别人的小辫子不放，这样只会让对方反感，会让你们的关系越来越僵。</p><p>当家人犯了错误，不要大声斥责，要知道此刻他的心里也特别难受，我们要学会安慰，让他们感觉到爱，等事后在委婉的讲道理。</p><p>当孩子犯了错误，不要一味地批评，要让他知道为什么会犯这样的错误，保证下次不会重犯。</p><p>生活实苦，我们且行且珍惜，面向大海吧，就算春暖不会花开，只要你能认真的对待生活，那么生活也一定会给你最好的反馈。</p><p>时间是最公平的东西。无论我们贫穷还是富有，30岁都会如期而至。</p><p>30岁，我们学会依靠自己的本领独立承担起自己应承受的责任，确定好自己的人生目标与发展方向。</p><p>到头来，你会知道，幸福根本没有从你身边溜走，只是你一直没有发现。</p><hr><p><strong>作者：林子树，富书签约作者，做过报社记者，媒体期刊写手，日更达人，我有一支笔，带你游红尘。本文首发富书</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;岁月太匆匆，在不经意间，第一批90后也很快就要步入30岁的行列。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://salmons.info/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>支付宝首页下拉刷新诡异的实现</title>
    <link href="http://salmons.info/2016/12/15/%E6%94%AF%E4%BB%98%E5%AE%9D%E9%A6%96%E9%A1%B5%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E8%AF%A1%E5%BC%82%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://salmons.info/2016/12/15/支付宝首页下拉刷新诡异的实现/</id>
    <published>2016-12-15T05:40:08.000Z</published>
    <updated>2018-12-17T05:59:37.385Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Demo地址: <a href="https://github.com/swifterfit/AlipayHomeRefresh" target="_blank" rel="noopener">https://github.com/swifterfit/AlipayHomeRefresh</a></strong><br><a id="more"></a><br>玩支付宝看到首页的效果，在这种特殊位置下拉刷新的效果，<em>其他效果如导航栏效果这里暂不处理</em>，觉得有意思，想搞一搞，如下图：</p><p><img src="http://oma38gsun.bkt.clouddn.com/AlipayHomeRefresh%E5%9B%BE1.png" alt=""></p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>分析一下我们要实现的：</p><ol><li>在区域1的位置操作下拉刷新，结果是区域2进行了刷新的视觉效果。</li><li>如果对屏幕任意位置操作上滑，整体都向上滑动了。</li><li>右侧的滑动指示器在区域2位置开始</li></ol><h3 id="方案设想"><a href="#方案设想" class="headerlink" title="方案设想"></a>方案设想</h3><p>有很多种方法实现，这里讲一种我想到的简单实现</p><p>比较简单，层级结构就不上图了。直接写在这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- self.view(控制器View)</span><br><span class="line">----- containerScrollView</span><br><span class="line">------- topView</span><br><span class="line">------- tableView</span><br></pre></td></tr></table></figure><p><code>self.view</code>下的<code>containerScrollView</code>容器，容器里面放着<code>topView</code>(区域1)和<code>tableView</code>(区域2)。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>主要由<code>scrollView</code>得代理方法来控制<code>tableView</code>的<code>contentOffset</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;</span><br><span class="line">    CGFloat offsetY = self.containerScrollView.contentOffset.y;</span><br><span class="line"></span><br><span class="line">//scrollView在原位置下拉时候，设置tableViewcontentOffset</span><br><span class="line">    if (offsetY &lt;= 0) &#123;     </span><br><span class="line">        self.topView.y = offsetY;</span><br><span class="line">        </span><br><span class="line">        self.tableView.y = offsetY + kTopViewHeight;</span><br><span class="line">        if (![self.tableView.mj_header isRefreshing]) &#123;</span><br><span class="line">            [self.tableView setContentOffset:CGPointMake(0, offsetY)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate &#123;</span><br><span class="line">    </span><br><span class="line">    CGFloat y = self.containerScrollView.contentOffset.y;</span><br><span class="line">    //scrollView下拉到相应位置执行刷新</span><br><span class="line">    if (y &lt; - 55) &#123; </span><br><span class="line">        [self.tableView.mj_header beginRefreshing];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="http://oma38gsun.bkt.clouddn.com/AlipayHomeRefresh.gif" alt=""></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>欢迎大家继续完善，并提供其他更简单的实现方案。</p><p>下拉刷新用了<a href="https://github.com/CoderMJLee/MJRefresh" target="_blank"><font color="blue"><u> MJRefresh </u></font></a>框架</p><p>为了<code>frame</code>方便书写，写了<code>UIView+Size</code>的分类</p><p>若Clone下来编译错误，请在项目路径下执行<code>pod install</code>后重新编译运行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Demo地址: &lt;a href=&quot;https://github.com/swifterfit/AlipayHomeRefresh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/swifterfit/AlipayHomeRefresh&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://salmons.info/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>淘宝选择规格动画效果</title>
    <link href="http://salmons.info/2016/10/21/%E6%B7%98%E5%AE%9D%E9%80%89%E6%8B%A9%E8%A7%84%E6%A0%BC%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/"/>
    <id>http://salmons.info/2016/10/21/淘宝选择规格动画效果/</id>
    <published>2016-10-21T08:10:26.000Z</published>
    <updated>2018-12-17T05:59:44.328Z</updated>
    
    <content type="html"><![CDATA[<p>很不幸，收到了裁员的通知，我们互联网团队30多人都收到了，应该只留1-2人，每个岗位。为了让我们愉快的度过十一，领导是在过节回来后和我们说的，<br><a id="more"></a><br>上面的指示是业务原因！！！补偿是有的，只是心理上还是有点接受不了，不多说了，也快两年了，感情是有的。最晚11月末离职。年前了，不知道工作好找么？</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>2017.03.14更新</p></blockquote><p>Demo: <a href="https://github.com/swifterfit/TaobaoPopAnimation" target="_blank" rel="noopener">https://github.com/swifterfit/TaobaoPopAnimation</a></p><p>总用淘宝，看到淘宝选择规格的凹陷的动画，就想到应该和维度和3D有关系，手痒，查了一些CATransform3D的资料。废话不多说，说一下我分解动画的思路步骤和主要代码：</p><p>先贴一下最终效果：</p><p><img src="http://oma38gsun.bkt.clouddn.com/TaobaoPopAnimation.gif" alt=""></p><h3 id="动画原理"><a href="#动画原理" class="headerlink" title="动画原理"></a>动画原理</h3><h5 id="先看底层凹陷的动画分解-称为rootView"><a href="#先看底层凹陷的动画分解-称为rootView" class="headerlink" title="先看底层凹陷的动画分解(称为rootView)"></a>先看底层凹陷的动画分解(称为rootView)</h5><ul><li>rootView的透视效果，同时缩小并上移一定距离</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (CATransform3D)firstTransform &#123;</span><br><span class="line">    </span><br><span class="line">    CATransform3D firstTransform = CATransform3DIdentity;</span><br><span class="line">    //透视效果，必须有下面的rotate结合，否则没有效果</span><br><span class="line">    firstTransform.m34 = 1.0/-1500;</span><br><span class="line">    //缩小的效果</span><br><span class="line">    firstTransform = CATransform3DScale(firstTransform, 0.95, 0.95, 1);</span><br><span class="line">    //绕x轴旋转</span><br><span class="line">    firstTransform = CATransform3DRotate(firstTransform, 15.0 * M_PI/180.0, 1, 0, 0);</span><br><span class="line">    //z轴位移</span><br><span class="line">    firstTransform = CATransform3DTranslate(firstTransform, 0, 0, -100);</span><br><span class="line">    </span><br><span class="line">    return firstTransform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为了视觉效果，再次制造透视效果，并且缩小移动，整体3d缩小的感觉。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (CATransform3D)secondTransform &#123;</span><br><span class="line">    </span><br><span class="line">    //恢复</span><br><span class="line">    CATransform3D secondTransform = CATransform3DIdentity;</span><br><span class="line">    //再来一次透视</span><br><span class="line">    secondTransform.m34 = [self firstTransform].m34;</span><br><span class="line">    //上移</span><br><span class="line">    secondTransform = CATransform3DTranslate(secondTransform, 0, self.rootView.frame.size.height * (-0.08), 0);</span><br><span class="line">    //再次缩小</span><br><span class="line">    secondTransform = CATransform3DScale(secondTransform, 0.85, 0.75, 1);</span><br><span class="line">    </span><br><span class="line">    return secondTransform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="再看底部上升视图-称为popView"><a href="#再看底部上升视图-称为popView" class="headerlink" title="再看底部上升视图(称为popView)"></a>再看底部上升视图(称为popView)</h5><ul><li>上升比较容易，主要看动画的时机。我放在了。上面的第2步里面同时进行。</li></ul><h5 id="看下接口"><a href="#看下接口" class="headerlink" title="看下接口"></a>看下接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 传入凹陷的rootView和底部弹出的popView</span><br><span class="line"></span><br><span class="line"> @param rootView 底层凹陷的View</span><br><span class="line"> @param popView 底部弹出的View</span><br><span class="line"> */</span><br><span class="line">- (void)startAnimationRootView:(UIView *)rootView andPopView:(UIView *)popView;</span><br></pre></td></tr></table></figure><p>只需要传入你需要做动画的两个view就好。 </p><p>可以把代码中一些参数提出来开放。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>做这种3d视觉效果的动画，基本上理解<code>CATransform3D</code>这个结构体每个成员的意义就差不多了。再配合平时用的scale、translate、等就够用了。 </p><p>知识量不多，但是挺有意思的，可以开发很多有创意的animation</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>关于<code>CATransform3D</code> 可以参考:</p><p><a href="http://geeklu.com/2012/07/ios-3d-perspective/" target="_blank" rel="noopener">iOS的三维透视投影</a></p><p><a href="http://blog.csdn.net/yujianxiang666/article/details/45333741" target="_blank" rel="noopener">Core Animation之CATransform3D:矩阵变换3D旋转</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很不幸，收到了裁员的通知，我们互联网团队30多人都收到了，应该只留1-2人，每个岗位。为了让我们愉快的度过十一，领导是在过节回来后和我们说的，&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://salmons.info/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>101. Symmetric Tree</title>
    <link href="http://salmons.info/2016/03/25/lc101/"/>
    <id>http://salmons.info/2016/03/25/lc101/</id>
    <published>2016-03-25T15:15:02.000Z</published>
    <updated>2019-02-20T11:30:03.359Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p><a id="more"></a><p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>But the following [1,2,2,null,3,null,3] is not:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>判断二叉树的对称性</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>用递归和遍历</p><p>遍历用到了队列</p><h4 id="C-代码："><a href="#C-代码：" class="headerlink" title="C++代码："></a>C++代码：</h4><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        </span><br><span class="line">        if (!root) return true;</span><br><span class="line">        return isSymmetric(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    bool isSymmetric(TreeNode *left, TreeNode *right) &#123;</span><br><span class="line">        if (!left &amp;&amp; !right) return true;</span><br><span class="line">        if (left &amp;&amp; !right || !left &amp;&amp; right || left-&gt;val != right-&gt;val) return false;</span><br><span class="line">        return isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        </span><br><span class="line">        if (!root) return true;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            TreeNode *node1 = q.front(); q.pop();</span><br><span class="line">            TreeNode *node2 = q.front(); q.pop();</span><br><span class="line">            if (!node1 &amp;&amp; !node2) continue;</span><br><span class="line">            if((node1 &amp;&amp; !node2) || (!node1 &amp;&amp; node2)) return false;</span><br><span class="line">            if (node1-&gt;val != node2-&gt;val) return false;</span><br><span class="line">            q.push(node1-&gt;left);</span><br><span class="line">            q.push(node2-&gt;right);</span><br><span class="line">            q.push(node1-&gt;right);</span><br><span class="line">            q.push(node2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://salmons.info/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>104. Maximum Depth of Binary Tree</title>
    <link href="http://salmons.info/2016/03/24/lc104/"/>
    <id>http://salmons.info/2016/03/24/lc104/</id>
    <published>2016-03-24T15:15:02.000Z</published>
    <updated>2019-02-20T09:34:42.213Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, find its maximum depth.<br><a id="more"></a><br>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p>Example:</p><p>Given binary tree [3,9,20,null,null,15,7],</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its depth = 3.</p><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>二叉树深度计算</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>DFS 用了递归<br>BFS 用了队列</p><h4 id="C-代码："><a href="#C-代码：" class="headerlink" title="C++代码："></a>C++代码：</h4><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            for (int i = q.size(); i &gt; 0; --i) &#123;</span><br><span class="line">                TreeNode *t = q.front(); q.pop();</span><br><span class="line">                if (t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">                if (t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, find its maximum depth.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://salmons.info/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>102. Binary Tree Level Order Traversal</title>
    <link href="http://salmons.info/2016/03/23/lc102/"/>
    <id>http://salmons.info/2016/03/23/lc102/</id>
    <published>2016-03-23T15:15:02.000Z</published>
    <updated>2019-02-12T11:32:35.554Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><a id="more"></a><p>Example:</p><p>Given binary tree [3,9,20,null,null,15,7],</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its level order traversal as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>层次遍历，返回数据为二维数组</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>返回的是二维数组，用到了队列数据结构，队列元素保存了(node, level), 节点和层级，遍历出队列，<br>如果当前的层级是第一次出现，就存入level对应的list，left入队列，right入队列</p><h4 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a>Python代码：</h4><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def levelOrder(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        from collections import deque</span><br><span class="line">        node_queue = deque()</span><br><span class="line">        node_queue.append((root, 0))</span><br><span class="line"></span><br><span class="line">        res, res_set = [], set()</span><br><span class="line"></span><br><span class="line">        while node_queue:</span><br><span class="line">            node, level = node_queue.popleft()</span><br><span class="line">            if node:</span><br><span class="line">                if level not in res_set:</span><br><span class="line">                    res_set.add(level)</span><br><span class="line">                    res.append([])</span><br><span class="line">                res[level].append(node.val)</span><br><span class="line">                node_queue.append((node.left, level + 1))</span><br><span class="line">                node_queue.append((node.right, level + 1))</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://salmons.info/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>145. Binary Tree Postorder Traversal</title>
    <link href="http://salmons.info/2016/03/22/lc145/"/>
    <id>http://salmons.info/2016/03/22/lc145/</id>
    <published>2016-03-22T15:15:02.000Z</published>
    <updated>2019-02-12T11:34:02.593Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p><a id="more"></a><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>中序遍历</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li>遍历：和先序遍历有点像，先序遍历是根-左-右， 先改成根-右-左，然后反转一下变成左-右-根，即为后序遍历</li><li>递归</li></ul><h4 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a>Python代码：</h4><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if root is None:</span><br><span class="line">            return []</span><br><span class="line">        stack, output = [root, ], []</span><br><span class="line">        while stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            output.append(root.val)</span><br><span class="line">            if root.left is not None:</span><br><span class="line">                stack.append(root.left)</span><br><span class="line">            if root.right is not None:</span><br><span class="line">                stack.append(root.right)</span><br><span class="line">        return output[::-1]</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root, res)</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def dfs(self, root, res):</span><br><span class="line">        if root:</span><br><span class="line">            self.dfs(root.left, res)</span><br><span class="line">            self.dfs(root.right, res)</span><br><span class="line">            res.append(root.val)</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, return the postorder traversal of its nodes’ values.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://salmons.info/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>94. Binary Tree Inorder Traversal</title>
    <link href="http://salmons.info/2016/03/21/lc94/"/>
    <id>http://salmons.info/2016/03/21/lc94/</id>
    <published>2016-03-21T15:15:02.000Z</published>
    <updated>2019-02-12T11:19:24.333Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p><a id="more"></a><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>中序遍历</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li>遍历：利用了stack数据结构，遍历root的left入栈，取出栈顶，加入output，栈顶元素的right替换，保证了左-根-右的顺序</li><li>递归</li></ul><h4 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a>Python代码：</h4><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if root is None:</span><br><span class="line">            return []</span><br><span class="line">        stack, output = [], []</span><br><span class="line">        p = root</span><br><span class="line">        while (stack or p):    </span><br><span class="line">            while p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            p = stack.pop()</span><br><span class="line">            output.append(p.val)</span><br><span class="line">            p = p.right</span><br><span class="line">        return output</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root, res)</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def dfs(self, root, res):</span><br><span class="line">        if root:</span><br><span class="line">            self.dfs(root.left, res)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            self.dfs(root.right, res)</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, return the inorder traversal of its nodes’ values.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://salmons.info/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>144. Binary Tree Preorder Traversal</title>
    <link href="http://salmons.info/2016/03/20/lc144/"/>
    <id>http://salmons.info/2016/03/20/lc144/</id>
    <published>2016-03-20T15:15:02.000Z</published>
    <updated>2019-02-12T11:22:22.625Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p><a id="more"></a><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>前序遍历</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li><p>遍历：利用了stack数据结构，root先入栈，遍历stack，每次取出栈顶，加入输出，栈顶元素right有值就入栈，栈顶元素left有值就入栈，保证了根-左-右的顺序</p></li><li><p>递归</p></li></ul><h4 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a>Python代码：</h4><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if root is None:</span><br><span class="line">            return []</span><br><span class="line">        </span><br><span class="line">        stack, output = [root, ], []</span><br><span class="line">        </span><br><span class="line">        while stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            if root is not None:</span><br><span class="line">                output.append(root.val)</span><br><span class="line">                if root.right is not None:</span><br><span class="line">                    stack.append(root.right)</span><br><span class="line">                if root.left is not None:</span><br><span class="line">                    stack.append(root.left)</span><br><span class="line">        </span><br><span class="line">        return output</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root, res)</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def dfs(self, root, res):</span><br><span class="line">        if root:</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            self.dfs(root.left, res)</span><br><span class="line">            self.dfs(root.right, res)</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, return the preorder traversal of its nodes’ values.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://salmons.info/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>61. Rotate List</title>
    <link href="http://salmons.info/2016/03/19/lc61/"/>
    <id>http://salmons.info/2016/03/19/lc61/</id>
    <published>2016-03-19T15:15:02.000Z</published>
    <updated>2019-01-31T07:06:50.259Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, rotate the list to the right by k places, where k is non-negative.<br><a id="more"></a></p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>旋转链表k步</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>先遍历整个链表获得链表长度n，然后此时把链表头和尾链接起来，在往后走n - k % n个节点就到达新链表的头结点前一个点，这时断开链表即可</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* rotateRight(struct ListNode* head, int k) &#123;</span><br><span class="line">    if(!head) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    int len = 1;</span><br><span class="line">    struct ListNode *cur = head;</span><br><span class="line">    while (cur-&gt;next) &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = head;</span><br><span class="line">    k %= len;</span><br><span class="line">    for (int i = 0; i &lt; len - k; i++) &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode *new = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = NULL;</span><br><span class="line">    return new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a linked list, rotate the list to the right by k places, where k is non-negative.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>21. Merge Two Sorted Lists</title>
    <link href="http://salmons.info/2016/03/18/lc21/"/>
    <id>http://salmons.info/2016/03/18/lc21/</id>
    <published>2016-03-18T15:15:02.000Z</published>
    <updated>2019-01-31T07:00:35.880Z</updated>
    
    <content type="html"><![CDATA[<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br><a id="more"></a></p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>合并两个有序的链表</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>遍历</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">        struct ListNode* newHead= (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line"></span><br><span class="line">   struct ListNode* cur = newHead;</span><br><span class="line"></span><br><span class="line">    while(l1 &amp;&amp; l2) &#123;</span><br><span class="line">        if(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = l1 ? l1 : l2;</span><br><span class="line">    return newHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>234. Palindrome Linked List</title>
    <link href="http://salmons.info/2016/03/17/lc234/"/>
    <id>http://salmons.info/2016/03/17/lc234/</id>
    <published>2016-03-17T15:15:02.000Z</published>
    <updated>2019-01-30T08:04:01.462Z</updated>
    
    <content type="html"><![CDATA[<p>Given a singly linked list, determine if it is a palindrome.<br><a id="more"></a></p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>Could you do it in O(n) time and O(1) space?</p><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>判断链表是否是回文</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>快慢指针遍历找到中点，以中点为头反转后半部分，同时遍历前半部分和后半部分</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//辅助函数，反转链表</span><br><span class="line">struct ListNode* reverseList(struct ListNode* head) &#123;</span><br><span class="line">    if(head == NULL || head-&gt;next == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode *newHead = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    return newHead;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isPalindrome(struct ListNode* head) &#123;</span><br><span class="line">    </span><br><span class="line">    struct ListNode *slow, *fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">        </span><br><span class="line">    while(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    //slow is midst</span><br><span class="line">    struct ListNode *half = reverseList(slow);</span><br><span class="line">    </span><br><span class="line">    while(half)&#123;</span><br><span class="line">        if(half-&gt;val == head-&gt;val)&#123;</span><br><span class="line">            half = half-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a singly linked list, determine if it is a palindrome.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>328. Odd Even Linked List</title>
    <link href="http://salmons.info/2016/03/16/lc328/"/>
    <id>http://salmons.info/2016/03/16/lc328/</id>
    <published>2016-03-16T15:15:02.000Z</published>
    <updated>2019-01-30T07:55:10.007Z</updated>
    
    <content type="html"><![CDATA[<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.<br><a id="more"></a><br>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</span><br><span class="line">Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:</p><ul><li>The relative order inside both the even and odd groups should remain as it was in the input.</li><li>The first node is considered odd, the second node even and so on …</li></ul><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>链表排序，先奇数后偶数</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>两个指针分别代表奇偶的头，另外一个指针提前保存偶数的头，跨越式遍历，最后奇数尾节点接偶数的头</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* oddEvenList(struct ListNode* head) &#123;</span><br><span class="line">        if (head == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct ListNode* odd = head;</span><br><span class="line">    struct ListNode* even = head-&gt;next;</span><br><span class="line">    struct ListNode* evenHead = even;</span><br><span class="line">    </span><br><span class="line">    while(even != NULL &amp;&amp; even-&gt;next != NULL)&#123;</span><br><span class="line">        odd-&gt;next = even-&gt;next;</span><br><span class="line">        odd = odd-&gt;next;</span><br><span class="line">        even-&gt;next = odd-&gt;next;</span><br><span class="line">        even = even-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    odd-&gt;next = evenHead;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>203. Remove Linked List Elements</title>
    <link href="http://salmons.info/2016/03/15/lc203/"/>
    <id>http://salmons.info/2016/03/15/lc203/</id>
    <published>2016-03-15T15:15:02.000Z</published>
    <updated>2019-01-30T07:46:13.076Z</updated>
    
    <content type="html"><![CDATA[<p>Remove all elements from a linked list of integers that have value val.<br><a id="more"></a></p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>删除值为val的所有节点</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>可以用递归和迭代分别实现</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* removeElements(struct ListNode* head, int val) &#123;</span><br><span class="line">    if (head == NULL) &#123;</span><br><span class="line">    return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    struct ListNode *cur = head;</span><br><span class="line">    </span><br><span class="line">    while (cur-&gt;next) &#123;</span><br><span class="line">        if (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* removeElements(struct ListNode* head, int val) &#123;</span><br><span class="line">    if (head == NULL) &#123;return NULL;&#125;</span><br><span class="line">    </span><br><span class="line">    head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">    return head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Remove all elements from a linked list of integers that have value val.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>206. Reverse Linked List</title>
    <link href="http://salmons.info/2016/03/14/lc206/"/>
    <id>http://salmons.info/2016/03/14/lc206/</id>
    <published>2016-03-14T15:15:02.000Z</published>
    <updated>2019-01-30T07:37:44.122Z</updated>
    
    <content type="html"><![CDATA[<p>Reverse a singly linked list.<br><a id="more"></a></p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>反转链表</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>可以用递归和迭代分别实现</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* reverseList(struct ListNode* head) &#123;</span><br><span class="line">    struct ListNode *prev = NULL;</span><br><span class="line">    struct ListNode *curr = head;</span><br><span class="line">   </span><br><span class="line">    while(curr!= NULL)&#123;</span><br><span class="line">       struct ListNode *temp = curr-&gt;next;</span><br><span class="line">       curr-&gt;next = prev;</span><br><span class="line">       prev = curr;</span><br><span class="line">       curr = temp; </span><br><span class="line">    &#125;</span><br><span class="line">    return prev; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* reverseList(struct ListNode* head) &#123;</span><br><span class="line">    if (!head || !head-&gt;next) return head;</span><br><span class="line">    struct ListNode *newHead = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Reverse a singly linked list.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>19. Remove Nth Node From End of List</title>
    <link href="http://salmons.info/2016/03/13/lc19/"/>
    <id>http://salmons.info/2016/03/13/lc19/</id>
    <published>2016-03-13T15:15:02.000Z</published>
    <updated>2019-01-29T06:43:12.199Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, remove the n-th node from the end of list and return its head.<br><a id="more"></a></p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>Given n will always be valid.</p><p><strong>Follow up:</strong></p><p>Could you do this in one pass?</p><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先 p1 和 p2 都指向 head，然后 p2 向前走 n 步，这样 p1 和 p2 之间就间隔 n 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123;</span><br><span class="line">    </span><br><span class="line">    if (!head) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    struct ListNode *p = head;</span><br><span class="line">    struct ListNode *q = head;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    for(i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (q == NULL) &#123;</span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(q-&gt;next != NULL)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">    free(q);</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a linked list, remove the n-th node from the end of list and return its head.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>160. Intersection of Two Linked Lists</title>
    <link href="http://salmons.info/2016/03/12/lc160/"/>
    <id>http://salmons.info/2016/03/12/lc160/</id>
    <published>2016-03-12T15:15:02.000Z</published>
    <updated>2019-01-29T06:35:04.551Z</updated>
    
    <content type="html"><![CDATA[<p>Write a program to find the node at which the intersection of two singly linked lists begins.<br><a id="more"></a><br>For example, the following two linked lists:<br><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt=""><br>begin to intersect at node c1.</p><p>Example:<br><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">Output: Reference of the node with value = 8</span><br><span class="line">Input Explanation: The intersected node&apos;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br></pre></td></tr></table></figure><p>Notes:</p><ul><li>If the two linked lists have no intersection at all, return null.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>两链表相交的第一个公共节点</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>两个链表的长度分别为l1,l2; 将较长的链表指针向后移动 l1 - l2 绝对值长度，然后开始同时遍历两个链表，知道两个指针相等，就是相交的第一个点</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int linkedListLength(struct ListNode *head) &#123;</span><br><span class="line">    </span><br><span class="line">    int length = 0;</span><br><span class="line">    </span><br><span class="line">    while(head != NULL)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123;</span><br><span class="line">    </span><br><span class="line">    int l1 = linkedListLength(headA);</span><br><span class="line">    int l2 = linkedListLength(headB); </span><br><span class="line"></span><br><span class="line">    struct ListNode *a = headA;</span><br><span class="line">    struct ListNode *b = headB;</span><br><span class="line"></span><br><span class="line">    if (l1 &gt; l2) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(i = 0; i &lt; l1 - l2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">       int i = 0;</span><br><span class="line">        for(i = 0; i &lt; l2 - l1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(a != b)&#123;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>142. Linked List Cycle II</title>
    <link href="http://salmons.info/2016/03/11/lc142/"/>
    <id>http://salmons.info/2016/03/11/lc142/</id>
    <published>2016-03-11T15:15:02.000Z</published>
    <updated>2019-01-29T06:10:07.891Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.<br><a id="more"></a><br>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p><p>Note: Do not modify the linked list.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: tail connects to node index 0</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>找到链表开始入环的第一个节点</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>按照 first 一步，second 两步，发现 first 和 second 重合，确定了单向链表有环路了。让first回到链表的头部，重新走，second不是走2了，而是走1，那么当 first 和 second 再次相遇的时候，就是环路的入口了。</p><p>假定起点到环入口点的距离为 a，first 和 second 的相交点X与环入口点的距离为b，环路的周长为c，当 first 和 second 第一次相遇的时候，假定 first 走了 n 步。那么有：</p><p>first走的路径： a+b ＝ n；<br>second走的路径： a+b+k<em>c = 2</em>n； second 比 first 多走了k圈环路，总路程是first的2倍</p><p>根据上面可以得到 k*c=a+b=n显然，如果从相遇点X开始，second 再走 n 步的话，还可以再回到相遇点，同时first从头开始走的话，经过n步，也会达到相遇点X。</p><p>显然在这个步骤当中 first 和 second 只有前 a 步走的路径不同，所以当 first 和 second 再次重合的时候，必然是在链表的环路入口点上。</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode *detectCycle(struct ListNode *head) &#123;</span><br><span class="line">    if (head == NULL) return NULL;</span><br><span class="line">    </span><br><span class="line">    struct ListNode* firstp = head;</span><br><span class="line">    struct ListNode* secondp = head;</span><br><span class="line">    bool isCycle = false;</span><br><span class="line">    </span><br><span class="line">    while(secondp-&gt;next != NULL &amp;&amp; secondp-&gt;next-&gt;next != NULL) &#123;</span><br><span class="line">        firstp = firstp-&gt;next;</span><br><span class="line">        secondp = secondp-&gt;next-&gt;next;</span><br><span class="line">        if (firstp == secondp) &#123; isCycle = true; break; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(!isCycle) return NULL;</span><br><span class="line">    firstp = head;</span><br><span class="line">    while( firstp != secondp) &#123;</span><br><span class="line">        firstp = firstp-&gt;next;</span><br><span class="line">        secondp = secondp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return firstp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a linked list, return the node where the cycle begins. If there is no cycle, return null.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>141. Linked List Cycle</title>
    <link href="http://salmons.info/2016/03/10/lc141/"/>
    <id>http://salmons.info/2016/03/10/lc141/</id>
    <published>2016-03-10T15:15:02.000Z</published>
    <updated>2019-01-29T03:29:09.320Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, determine if it has a cycle in it.<br><a id="more"></a><br>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>判断链表是否有环</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>快慢指针遍历</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool hasCycle(struct ListNode *head) &#123;</span><br><span class="line">    </span><br><span class="line">    if (head == NULL) return false;</span><br><span class="line">    </span><br><span class="line">    struct ListNode* firstp = head;</span><br><span class="line">    struct ListNode* secondp = head;</span><br><span class="line">    </span><br><span class="line">    while(secondp-&gt;next != NULL &amp;&amp; secondp-&gt;next-&gt;next != NULL) &#123;</span><br><span class="line">        firstp = firstp-&gt;next;</span><br><span class="line">        secondp = secondp-&gt;next-&gt;next;</span><br><span class="line">        if (firstp == secondp) &#123; return true; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>707. Design Linked List</title>
    <link href="http://salmons.info/2016/03/09/lc707/"/>
    <id>http://salmons.info/2016/03/09/lc707/</id>
    <published>2016-03-09T15:15:02.000Z</published>
    <updated>2019-01-29T02:33:46.336Z</updated>
    
    <content type="html"><![CDATA[<p>Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should<br><a id="more"></a><br>have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p><p>Implement these functions in your linked list class:</p><ul><li>get(index) : Get the value of the index-th node in the linked list. If the index is invalid, return -1.</li><li>addAtHead(val) : Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li><li>addAtTail(val) : Append a node of value val to the last element of the linked list.</li><li>addAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</li><li>deleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid.</li></ul><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyLinkedList linkedList = new MyLinkedList();</span><br><span class="line">linkedList.addAtHead(1);</span><br><span class="line">linkedList.addAtTail(3);</span><br><span class="line">linkedList.addAtIndex(1, 2);  // linked list becomes 1-&gt;2-&gt;3</span><br><span class="line">linkedList.get(1);            // returns 2</span><br><span class="line">linkedList.deleteAtIndex(1);  // now the linked list is 1-&gt;3</span><br><span class="line">linkedList.get(1);            // returns 3</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>设计链表的几种基本操作</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>下文代码含有头指针。</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">typedef struct node&#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct node *next;</span><br><span class="line">&#125; MyLinkedList;</span><br><span class="line"></span><br><span class="line">MyLinkedList* myLinkedListCreate()</span><br><span class="line">&#123;</span><br><span class="line">    MyLinkedList *head = (MyLinkedList *)malloc(sizeof(MyLinkedList));</span><br><span class="line">    head-&gt;val = 0;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line">    </span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printLinkedList(MyLinkedList *obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj == NULL || obj-&gt;next == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    MyLinkedList *cur = obj-&gt;next;</span><br><span class="line">    while (cur) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, cur-&gt;val);</span><br><span class="line">        printf(&quot;-&gt;&quot;);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int myLinkedListGet(MyLinkedList* obj, int index)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj == NULL || obj-&gt;next == NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    MyLinkedList* cur = obj-&gt;next;</span><br><span class="line">    while (cur != NULL) &#123;</span><br><span class="line">        if (i == index) &#123;</span><br><span class="line">            return cur-&gt;val;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            i++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myLinkedListAddAtHead(MyLinkedList* obj, int val)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyLinkedList* node = (MyLinkedList *)malloc(sizeof(MyLinkedList));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;next = obj-&gt;next;</span><br><span class="line">    obj-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myLinkedListAddAtTail(MyLinkedList* obj, int val)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyLinkedList* node = (MyLinkedList *)malloc(sizeof(MyLinkedList));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;next = NULL;</span><br><span class="line">    </span><br><span class="line">    if (obj-&gt;next == NULL) &#123;</span><br><span class="line">        obj-&gt;next = node;</span><br><span class="line">    &#125; else  &#123;</span><br><span class="line">        MyLinkedList* cur = obj-&gt;next;</span><br><span class="line">        while (cur-&gt;next != NULL) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    </span><br><span class="line">    if (obj == NULL || index &lt; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyLinkedList* node = (MyLinkedList *)malloc(sizeof(MyLinkedList));</span><br><span class="line">    if (index == 0) &#123;</span><br><span class="line">        node-&gt;val = val;</span><br><span class="line">        node-&gt;next = obj-&gt;next;</span><br><span class="line">        obj-&gt;next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        MyLinkedList* pre = obj;</span><br><span class="line">        MyLinkedList* cur = obj-&gt;next;</span><br><span class="line">        i=0;</span><br><span class="line">        while (i &lt; index &amp;&amp; cur != 0) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i == index) &#123;</span><br><span class="line">            node-&gt;val = val;</span><br><span class="line">            node-&gt;next = cur;</span><br><span class="line">            pre-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index)</span><br><span class="line">&#123;</span><br><span class="line">    MyLinkedList* tmp;</span><br><span class="line">    int i = 0;</span><br><span class="line">    </span><br><span class="line">    if (obj == NULL || obj-&gt;next == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (index == 0) &#123;</span><br><span class="line">        tmp = obj-&gt;next;</span><br><span class="line">        obj-&gt;next = tmp-&gt;next;</span><br><span class="line">        free(tmp);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        MyLinkedList* pre = obj;</span><br><span class="line">        MyLinkedList* cur = obj-&gt;next;</span><br><span class="line">        while (i &lt; index &amp;&amp; cur != 0) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i == index &amp;&amp; cur != 0) &#123;</span><br><span class="line">            tmp = cur;</span><br><span class="line">            pre-&gt;next = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myLinkedListFree(MyLinkedList* obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyLinkedList* cur = obj-&gt;next;</span><br><span class="line">    while(cur != 0) &#123;</span><br><span class="line">        obj-&gt;next = cur-&gt;next;</span><br><span class="line">        free(cur);</span><br><span class="line">        cur = obj-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    free(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
</feed>

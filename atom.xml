<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Salmons&#39;s Pool</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://salmons.info/"/>
  <updated>2018-12-17T06:02:26.468Z</updated>
  <id>http://salmons.info/</id>
  
  <author>
    <name>Salmons</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>送给30岁的自己</title>
    <link href="http://salmons.info/2018/12/17/to30self/"/>
    <id>http://salmons.info/2018/12/17/to30self/</id>
    <published>2018-12-17T04:47:55.000Z</published>
    <updated>2018-12-17T06:02:26.468Z</updated>
    
    <content type="html"><![CDATA[<p>岁月太匆匆，在不经意间，第一批90后也很快就要步入30岁的行列。<br><a id="more"></a><br>有人说：<br>30岁是一个尴尬的阶段，我们大多事业还未有成，上有老下有小，成了一家人的顶梁柱。</p><p>30岁的年轻人，很容易患上“初老症”，梦想逐渐褪色，生活尽是苦涩。</p><p>如何让自己保持对生活的信心，不至于未老先衰，意志消退，其实是所有第一批90后要面对的难题。</p><p>时间可以改变我们的形象，但绝不会改变我们内心的渴望。</p><p>一旦进入了30岁，就不能孩子气了，下面这个10个道理，你必须要知道。</p><h4 id="01-一定要学会走自己的路"><a href="#01-一定要学会走自己的路" class="headerlink" title="01 一定要学会走自己的路"></a>01 一定要学会走自己的路</h4><p>进入30岁这个行列，别人的目光真的没那么重要了，他们的看法不会对我们的人生造成很大的影响，不会成为我们人生路上的绊脚石。</p><p>我们要学会走自己的路，让别人随便去说。</p><p>只要无愧于心，无愧于己就足够了。</p><p>我们不应该活在别人的眼光里，也不应该裹足于别人的唾沫里，更不应该活在别人给予的砝码之上。</p><p>一个人成熟的本质，就是了解到自己是人生唯一的责任人。</p><p>不要害怕别人看不起你，也不要和每个人都坦诚相待，为了自己的既定目标努力去奋斗就够了，只要努力了，我相信总有出头日。</p><h4 id="02-要学会懂自己"><a href="#02-要学会懂自己" class="headerlink" title="02 要学会懂自己"></a>02 要学会懂自己</h4><p>廖一梅曾说：<br>人这一辈子遇到爱，遇到性都不稀罕，稀罕的是遇到了解。</p><p>确实在生活中我们很难遇到懂自己的人。</p><p>我们小时候都曾与小伙伴山盟海誓，要一辈子做彼此的背膀。</p><p>可是，走着走着，许多曾经的好友都走散了，许多美好的回忆，只能在酒后谈起。</p><p>人这一辈子，遇到投机的人很容易，可是找一个能一直懂自己的人很难。</p><p>无论在婚姻里，还是职场里，我们可能一直找不到那个人，但也没必要遗憾，尽力就好。</p><p>有个人懂你是幸福的，如果没人懂那也是人生常态。你要学会自己懂自己，这世上没有任何人比你更爱自己。</p><h4 id="03-放宽心态，别斤斤计较"><a href="#03-放宽心态，别斤斤计较" class="headerlink" title="03 放宽心态，别斤斤计较"></a>03 放宽心态，别斤斤计较</h4><p>30岁，我们大多已经褪去年少轻狂，不再执迷于诗和远方。生活给予我们的更多是重复和苦涩。</p><p>油盐酱醋的生活里，琐事很多，可能经常会让我们毫无头绪，焦躁不安，慢慢变得怨天尤人，毫无乐趣。</p><p>其实，这只不过是自寻烦恼。</p><p>30岁了，要学会放下计较。那些鸡毛蒜皮的事情，真的没什么意思。计较的后果只会让自己更加生气，甚至会怀疑人生，还不如放宽心态，好好的生活。</p><p>生活越是向我们展现它无聊的一面，我们就越要保持平和的心态。就像电影《七宗罪》里最后说的：生活虽然不美好，但仍然值得去守护。</p><p>一个人的生活态度决定了他的生活质量，如果你不好好生活，那么一定会得到生活最残酷的惩罚。</p><h4 id="04-过好当下，别对最亲近的人发脾气"><a href="#04-过好当下，别对最亲近的人发脾气" class="headerlink" title="04 过好当下，别对最亲近的人发脾气"></a>04 过好当下，别对最亲近的人发脾气</h4><p>无论工作还是生活中，我们可能会有很多烦恼，但千万不要把这种烦恼发泄在最近亲的人身上。这样只会伤害他们，让他们也倍感压抑。</p><p>看过一个小故事：</p><p>有个人每次在单位里受了气，都不会直接回家，而是在一棵树底下呆一会，对着大树发泄自己的情绪，发泄完了，就收拾好心情回家。</p><p>这样的人，无论个人成就大还是小，都是一个有担当的人。因为家人是我们最后的港湾，也是我们活下去的动力。</p><p>《蝙蝠侠·黑暗骑士》里说：真正衡量英雄的标准，不在于他多有力量，而在于他能承受多少的苦难</p><p>外面的世界已经充满刀枪剑戟，让家人舒心和快乐，就是最好的英雄主义。</p><p>其实，生活真的很幸福，是我们要求太多了，当你能珍惜眼前的生活时，你定会发现这份生活是多么的美好。</p><h4 id="05-一定要学会珍惜友情"><a href="#05-一定要学会珍惜友情" class="headerlink" title="05 一定要学会珍惜友情"></a>05 一定要学会珍惜友情</h4><p>30岁以后，我们终于领悟到朋友的重要性。</p><p>马克思说：人是社会关系的总和。<br>有人说：多一个朋友多一条路。</p><p>朋友是资源，但更要的是，朋友是我们生活在这个残酷世界的需要。</p><p>没有朋友的孤家寡人，永远不可成大器，千金散去，还复来，朋友走了，就不会回来了。</p><p>当然没必要把时间花在酒肉朋友身上，因为他们不值得我们交往，我们需要的是彼此坦诚相待的好兄弟，朋友不要求多，而在于精，真心的有一两个就够了。</p><h4 id="06-一定要学会体谅父母"><a href="#06-一定要学会体谅父母" class="headerlink" title="06 一定要学会体谅父母"></a>06 一定要学会体谅父母</h4><p>生活中，我们经常会嫌弃父母唠叨，觉得他们根本不懂我们的生活，可你要知道父母都是为了我们好，当我们为人父母了，才懂得这份唠叨里藏着满满的爱。</p><p>30多岁了，千万别再嫌他们唠叨，我们和父母之间的缘分也越来越浅了，很可能一转身就再也不想见了，学会体谅父母，多花一些时间陪他们。</p><p>在父母的眼里我们永远都是孩子，我们长大了，他们也真的老了，现在我们得多哄他们开心了，多给他们打电话，这样他们才会安心。</p><h4 id="07-爱自己的工作，爱自己的身体"><a href="#07-爱自己的工作，爱自己的身体" class="headerlink" title="07 爱自己的工作，爱自己的身体"></a>07 爱自己的工作，爱自己的身体</h4><p>人一定要学会独立自主，尤其到了30岁这个行列。有些人结婚后，就不想工作了，想呆在家里过衣食无忧的生活。</p><p>无论男女都要有自己的一份工作，这是你人生的意义。</p><p>这份工作可能不会给你带来很多金钱上的收获，但却能让你获得成长，只要能让你的人生得到淬炼，这就足够了。</p><p>30多岁，真的是一个很尴尬的阶段，这个阶段我们压力很大，你可千万不要忘了爱自己，我们是家里的顶梁柱，如果没有我们，那么这个家就彻底完蛋了，一定要学会爱惜自己的身体。</p><p>因为这才是你革命的本钱，能不熬夜就别熬夜了，能对自己好一点就对自己好一点。</p><p>只有我们在，那么这个家才不会垮掉！一家老小才会生活在幸福之中。</p><h4 id="08不要攀比，更不要爱慕虚荣"><a href="#08不要攀比，更不要爱慕虚荣" class="headerlink" title="08不要攀比，更不要爱慕虚荣"></a>08不要攀比，更不要爱慕虚荣</h4><p>20多岁，我们喜欢攀比，喜欢好手机，喜欢好车，因为攀比我们成了月光族。</p><p>30多岁你需要活得成熟一些，所有的东西都是过眼云烟，真实地活着才是最重要的。</p><p>我们没必要追求大房子，追求豪车，你要知道，房子再大，你需要的不过是一张能够安然入睡的床，车子再好不过也是用来代步。</p><p>我们完全没必要羡慕别人一身名牌，不要羡慕她们奢侈的包包，因为这些都是身外之物，30多岁活得快乐才最重要的。</p><p>如果一个人把心思一直放在盲目攀比上，那么他的生活绝对不会幸福。</p><h4 id="09-三观不同不必强融"><a href="#09-三观不同不必强融" class="headerlink" title="09 三观不同不必强融"></a>09 三观不同不必强融</h4><p>萧伯纳说过：<br>自我控制是最强者的本能。</p><p>生活中我们会和很多人的三观不一样，既然不一样，那么就不要试图说服对方，伤了自己也伤了别人。</p><p>对待事情，每个人都有自己的看法，如果是对的你就选择坚持，要是不对的就学会改正。</p><p>更不要跟强词夺理的人交谈，因为这只会浪费你大量的时间，你的世界他们根本不懂。</p><p>30多岁了，就要活得通透了，当在生活中遭受到不被理解时，没必要急着去争个输赢。时间自然会给你最好的答案。</p><h4 id="10-学会理解和包容"><a href="#10-学会理解和包容" class="headerlink" title="10 学会理解和包容"></a>10 学会理解和包容</h4><p>人非圣贤孰能无过，所以对身边的人和事要学会包容，千万不要揪着别人的小辫子不放，这样只会让对方反感，会让你们的关系越来越僵。</p><p>当家人犯了错误，不要大声斥责，要知道此刻他的心里也特别难受，我们要学会安慰，让他们感觉到爱，等事后在委婉的讲道理。</p><p>当孩子犯了错误，不要一味地批评，要让他知道为什么会犯这样的错误，保证下次不会重犯。</p><p>生活实苦，我们且行且珍惜，面向大海吧，就算春暖不会花开，只要你能认真的对待生活，那么生活也一定会给你最好的反馈。</p><p>时间是最公平的东西。无论我们贫穷还是富有，30岁都会如期而至。</p><p>30岁，我们学会依靠自己的本领独立承担起自己应承受的责任，确定好自己的人生目标与发展方向。</p><p>到头来，你会知道，幸福根本没有从你身边溜走，只是你一直没有发现。</p><hr><p><strong>作者：林子树，富书签约作者，做过报社记者，媒体期刊写手，日更达人，我有一支笔，带你游红尘。本文首发富书</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;岁月太匆匆，在不经意间，第一批90后也很快就要步入30岁的行列。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://salmons.info/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>支付宝首页下拉刷新诡异的实现</title>
    <link href="http://salmons.info/2016/12/15/%E6%94%AF%E4%BB%98%E5%AE%9D%E9%A6%96%E9%A1%B5%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E8%AF%A1%E5%BC%82%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://salmons.info/2016/12/15/支付宝首页下拉刷新诡异的实现/</id>
    <published>2016-12-15T05:40:08.000Z</published>
    <updated>2018-12-17T05:59:37.385Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Demo地址: <a href="https://github.com/swifterfit/AlipayHomeRefresh" target="_blank" rel="noopener">https://github.com/swifterfit/AlipayHomeRefresh</a></strong><br><a id="more"></a><br>玩支付宝看到首页的效果，在这种特殊位置下拉刷新的效果，<em>其他效果如导航栏效果这里暂不处理</em>，觉得有意思，想搞一搞，如下图：</p><p><img src="http://oma38gsun.bkt.clouddn.com/AlipayHomeRefresh%E5%9B%BE1.png" alt=""></p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>分析一下我们要实现的：</p><ol><li>在区域1的位置操作下拉刷新，结果是区域2进行了刷新的视觉效果。</li><li>如果对屏幕任意位置操作上滑，整体都向上滑动了。</li><li>右侧的滑动指示器在区域2位置开始</li></ol><h3 id="方案设想"><a href="#方案设想" class="headerlink" title="方案设想"></a>方案设想</h3><p>有很多种方法实现，这里讲一种我想到的简单实现</p><p>比较简单，层级结构就不上图了。直接写在这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- self.view(控制器View)</span><br><span class="line">----- containerScrollView</span><br><span class="line">------- topView</span><br><span class="line">------- tableView</span><br></pre></td></tr></table></figure><p><code>self.view</code>下的<code>containerScrollView</code>容器，容器里面放着<code>topView</code>(区域1)和<code>tableView</code>(区域2)。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>主要由<code>scrollView</code>得代理方法来控制<code>tableView</code>的<code>contentOffset</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;</span><br><span class="line">    CGFloat offsetY = self.containerScrollView.contentOffset.y;</span><br><span class="line"></span><br><span class="line">//scrollView在原位置下拉时候，设置tableViewcontentOffset</span><br><span class="line">    if (offsetY &lt;= 0) &#123;     </span><br><span class="line">        self.topView.y = offsetY;</span><br><span class="line">        </span><br><span class="line">        self.tableView.y = offsetY + kTopViewHeight;</span><br><span class="line">        if (![self.tableView.mj_header isRefreshing]) &#123;</span><br><span class="line">            [self.tableView setContentOffset:CGPointMake(0, offsetY)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate &#123;</span><br><span class="line">    </span><br><span class="line">    CGFloat y = self.containerScrollView.contentOffset.y;</span><br><span class="line">    //scrollView下拉到相应位置执行刷新</span><br><span class="line">    if (y &lt; - 55) &#123; </span><br><span class="line">        [self.tableView.mj_header beginRefreshing];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="http://oma38gsun.bkt.clouddn.com/AlipayHomeRefresh.gif" alt=""></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>欢迎大家继续完善，并提供其他更简单的实现方案。</p><p>下拉刷新用了<a href="https://github.com/CoderMJLee/MJRefresh" target="_blank"><font color="blue"><u> MJRefresh </u></font></a>框架</p><p>为了<code>frame</code>方便书写，写了<code>UIView+Size</code>的分类</p><p>若Clone下来编译错误，请在项目路径下执行<code>pod install</code>后重新编译运行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Demo地址: &lt;a href=&quot;https://github.com/swifterfit/AlipayHomeRefresh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/swifterfit/AlipayHomeRefresh&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://salmons.info/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>淘宝选择规格动画效果</title>
    <link href="http://salmons.info/2016/10/21/%E6%B7%98%E5%AE%9D%E9%80%89%E6%8B%A9%E8%A7%84%E6%A0%BC%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/"/>
    <id>http://salmons.info/2016/10/21/淘宝选择规格动画效果/</id>
    <published>2016-10-21T08:10:26.000Z</published>
    <updated>2018-12-17T05:59:44.328Z</updated>
    
    <content type="html"><![CDATA[<p>很不幸，收到了裁员的通知，我们互联网团队30多人都收到了，应该只留1-2人，每个岗位。为了让我们愉快的度过十一，领导是在过节回来后和我们说的，<br><a id="more"></a><br>上面的指示是业务原因！！！补偿是有的，只是心理上还是有点接受不了，不多说了，也快两年了，感情是有的。最晚11月末离职。年前了，不知道工作好找么？</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>2017.03.14更新</p></blockquote><p>Demo: <a href="https://github.com/swifterfit/TaobaoPopAnimation" target="_blank" rel="noopener">https://github.com/swifterfit/TaobaoPopAnimation</a></p><p>总用淘宝，看到淘宝选择规格的凹陷的动画，就想到应该和维度和3D有关系，手痒，查了一些CATransform3D的资料。废话不多说，说一下我分解动画的思路步骤和主要代码：</p><p>先贴一下最终效果：</p><p><img src="http://oma38gsun.bkt.clouddn.com/TaobaoPopAnimation.gif" alt=""></p><h3 id="动画原理"><a href="#动画原理" class="headerlink" title="动画原理"></a>动画原理</h3><h5 id="先看底层凹陷的动画分解-称为rootView"><a href="#先看底层凹陷的动画分解-称为rootView" class="headerlink" title="先看底层凹陷的动画分解(称为rootView)"></a>先看底层凹陷的动画分解(称为rootView)</h5><ul><li>rootView的透视效果，同时缩小并上移一定距离</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (CATransform3D)firstTransform &#123;</span><br><span class="line">    </span><br><span class="line">    CATransform3D firstTransform = CATransform3DIdentity;</span><br><span class="line">    //透视效果，必须有下面的rotate结合，否则没有效果</span><br><span class="line">    firstTransform.m34 = 1.0/-1500;</span><br><span class="line">    //缩小的效果</span><br><span class="line">    firstTransform = CATransform3DScale(firstTransform, 0.95, 0.95, 1);</span><br><span class="line">    //绕x轴旋转</span><br><span class="line">    firstTransform = CATransform3DRotate(firstTransform, 15.0 * M_PI/180.0, 1, 0, 0);</span><br><span class="line">    //z轴位移</span><br><span class="line">    firstTransform = CATransform3DTranslate(firstTransform, 0, 0, -100);</span><br><span class="line">    </span><br><span class="line">    return firstTransform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为了视觉效果，再次制造透视效果，并且缩小移动，整体3d缩小的感觉。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (CATransform3D)secondTransform &#123;</span><br><span class="line">    </span><br><span class="line">    //恢复</span><br><span class="line">    CATransform3D secondTransform = CATransform3DIdentity;</span><br><span class="line">    //再来一次透视</span><br><span class="line">    secondTransform.m34 = [self firstTransform].m34;</span><br><span class="line">    //上移</span><br><span class="line">    secondTransform = CATransform3DTranslate(secondTransform, 0, self.rootView.frame.size.height * (-0.08), 0);</span><br><span class="line">    //再次缩小</span><br><span class="line">    secondTransform = CATransform3DScale(secondTransform, 0.85, 0.75, 1);</span><br><span class="line">    </span><br><span class="line">    return secondTransform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="再看底部上升视图-称为popView"><a href="#再看底部上升视图-称为popView" class="headerlink" title="再看底部上升视图(称为popView)"></a>再看底部上升视图(称为popView)</h5><ul><li>上升比较容易，主要看动画的时机。我放在了。上面的第2步里面同时进行。</li></ul><h5 id="看下接口"><a href="#看下接口" class="headerlink" title="看下接口"></a>看下接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 传入凹陷的rootView和底部弹出的popView</span><br><span class="line"></span><br><span class="line"> @param rootView 底层凹陷的View</span><br><span class="line"> @param popView 底部弹出的View</span><br><span class="line"> */</span><br><span class="line">- (void)startAnimationRootView:(UIView *)rootView andPopView:(UIView *)popView;</span><br></pre></td></tr></table></figure><p>只需要传入你需要做动画的两个view就好。 </p><p>可以把代码中一些参数提出来开放。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>做这种3d视觉效果的动画，基本上理解<code>CATransform3D</code>这个结构体每个成员的意义就差不多了。再配合平时用的scale、translate、等就够用了。 </p><p>知识量不多，但是挺有意思的，可以开发很多有创意的animation</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>关于<code>CATransform3D</code> 可以参考:</p><p><a href="http://geeklu.com/2012/07/ios-3d-perspective/" target="_blank" rel="noopener">iOS的三维透视投影</a></p><p><a href="http://blog.csdn.net/yujianxiang666/article/details/45333741" target="_blank" rel="noopener">Core Animation之CATransform3D:矩阵变换3D旋转</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很不幸，收到了裁员的通知，我们互联网团队30多人都收到了，应该只留1-2人，每个岗位。为了让我们愉快的度过十一，领导是在过节回来后和我们说的，&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://salmons.info/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>104. Maximum Depth of Binary Tree</title>
    <link href="http://salmons.info/2016/03/24/lc104/"/>
    <id>http://salmons.info/2016/03/24/lc104/</id>
    <published>2016-03-24T15:15:02.000Z</published>
    <updated>2019-02-19T03:11:06.580Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, find its maximum depth.<br><a id="more"></a><br>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p>Example:</p><p>Given binary tree [3,9,20,null,null,15,7],</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its depth = 3.</p><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>二叉树深度计算</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>DFS 用了递归<br>BFS 用了队列</p><h4 id="C-代码："><a href="#C-代码：" class="headerlink" title="C++代码："></a>C++代码：</h4><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            for (int i = q.size(); i &gt; 0; --i) &#123;</span><br><span class="line">                TreeNode *t = q.front(); q.pop();</span><br><span class="line">                if (t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">                if (t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, find its maximum depth.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://salmons.info/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>102. Binary Tree Level Order Traversal</title>
    <link href="http://salmons.info/2016/03/23/lc102/"/>
    <id>http://salmons.info/2016/03/23/lc102/</id>
    <published>2016-03-23T15:15:02.000Z</published>
    <updated>2019-02-12T11:32:35.554Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><a id="more"></a><p>Example:</p><p>Given binary tree [3,9,20,null,null,15,7],</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its level order traversal as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>层次遍历，返回数据为二维数组</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>返回的是二维数组，用到了队列数据结构，队列元素保存了(node, level), 节点和层级，遍历出队列，<br>如果当前的层级是第一次出现，就存入level对应的list，left入队列，right入队列</p><h4 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a>Python代码：</h4><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def levelOrder(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        from collections import deque</span><br><span class="line">        node_queue = deque()</span><br><span class="line">        node_queue.append((root, 0))</span><br><span class="line"></span><br><span class="line">        res, res_set = [], set()</span><br><span class="line"></span><br><span class="line">        while node_queue:</span><br><span class="line">            node, level = node_queue.popleft()</span><br><span class="line">            if node:</span><br><span class="line">                if level not in res_set:</span><br><span class="line">                    res_set.add(level)</span><br><span class="line">                    res.append([])</span><br><span class="line">                res[level].append(node.val)</span><br><span class="line">                node_queue.append((node.left, level + 1))</span><br><span class="line">                node_queue.append((node.right, level + 1))</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://salmons.info/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>145. Binary Tree Postorder Traversal</title>
    <link href="http://salmons.info/2016/03/22/lc145/"/>
    <id>http://salmons.info/2016/03/22/lc145/</id>
    <published>2016-03-22T15:15:02.000Z</published>
    <updated>2019-02-12T11:34:02.593Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p><a id="more"></a><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>中序遍历</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li>遍历：和先序遍历有点像，先序遍历是根-左-右， 先改成根-右-左，然后反转一下变成左-右-根，即为后序遍历</li><li>递归</li></ul><h4 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a>Python代码：</h4><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if root is None:</span><br><span class="line">            return []</span><br><span class="line">        stack, output = [root, ], []</span><br><span class="line">        while stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            output.append(root.val)</span><br><span class="line">            if root.left is not None:</span><br><span class="line">                stack.append(root.left)</span><br><span class="line">            if root.right is not None:</span><br><span class="line">                stack.append(root.right)</span><br><span class="line">        return output[::-1]</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root, res)</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def dfs(self, root, res):</span><br><span class="line">        if root:</span><br><span class="line">            self.dfs(root.left, res)</span><br><span class="line">            self.dfs(root.right, res)</span><br><span class="line">            res.append(root.val)</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, return the postorder traversal of its nodes’ values.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://salmons.info/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>94. Binary Tree Inorder Traversal</title>
    <link href="http://salmons.info/2016/03/21/lc94/"/>
    <id>http://salmons.info/2016/03/21/lc94/</id>
    <published>2016-03-21T15:15:02.000Z</published>
    <updated>2019-02-12T11:19:24.333Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p><a id="more"></a><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>中序遍历</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li>遍历：利用了stack数据结构，遍历root的left入栈，取出栈顶，加入output，栈顶元素的right替换，保证了左-根-右的顺序</li><li>递归</li></ul><h4 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a>Python代码：</h4><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if root is None:</span><br><span class="line">            return []</span><br><span class="line">        stack, output = [], []</span><br><span class="line">        p = root</span><br><span class="line">        while (stack or p):    </span><br><span class="line">            while p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            p = stack.pop()</span><br><span class="line">            output.append(p.val)</span><br><span class="line">            p = p.right</span><br><span class="line">        return output</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root, res)</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def dfs(self, root, res):</span><br><span class="line">        if root:</span><br><span class="line">            self.dfs(root.left, res)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            self.dfs(root.right, res)</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, return the inorder traversal of its nodes’ values.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://salmons.info/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>144. Binary Tree Preorder Traversal</title>
    <link href="http://salmons.info/2016/03/20/lc144/"/>
    <id>http://salmons.info/2016/03/20/lc144/</id>
    <published>2016-03-20T15:15:02.000Z</published>
    <updated>2019-02-12T11:22:22.625Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p><a id="more"></a><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>前序遍历</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li><p>遍历：利用了stack数据结构，root先入栈，遍历stack，每次取出栈顶，加入输出，栈顶元素right有值就入栈，栈顶元素left有值就入栈，保证了根-左-右的顺序</p></li><li><p>递归</p></li></ul><h4 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a>Python代码：</h4><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if root is None:</span><br><span class="line">            return []</span><br><span class="line">        </span><br><span class="line">        stack, output = [root, ], []</span><br><span class="line">        </span><br><span class="line">        while stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            if root is not None:</span><br><span class="line">                output.append(root.val)</span><br><span class="line">                if root.right is not None:</span><br><span class="line">                    stack.append(root.right)</span><br><span class="line">                if root.left is not None:</span><br><span class="line">                    stack.append(root.left)</span><br><span class="line">        </span><br><span class="line">        return output</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root, res)</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def dfs(self, root, res):</span><br><span class="line">        if root:</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            self.dfs(root.left, res)</span><br><span class="line">            self.dfs(root.right, res)</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, return the preorder traversal of its nodes’ values.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="BinaryTree" scheme="http://salmons.info/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>61. Rotate List</title>
    <link href="http://salmons.info/2016/03/19/lc61/"/>
    <id>http://salmons.info/2016/03/19/lc61/</id>
    <published>2016-03-19T15:15:02.000Z</published>
    <updated>2019-01-31T07:06:50.259Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, rotate the list to the right by k places, where k is non-negative.<br><a id="more"></a></p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>旋转链表k步</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>先遍历整个链表获得链表长度n，然后此时把链表头和尾链接起来，在往后走n - k % n个节点就到达新链表的头结点前一个点，这时断开链表即可</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* rotateRight(struct ListNode* head, int k) &#123;</span><br><span class="line">    if(!head) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    int len = 1;</span><br><span class="line">    struct ListNode *cur = head;</span><br><span class="line">    while (cur-&gt;next) &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = head;</span><br><span class="line">    k %= len;</span><br><span class="line">    for (int i = 0; i &lt; len - k; i++) &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode *new = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = NULL;</span><br><span class="line">    return new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a linked list, rotate the list to the right by k places, where k is non-negative.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>21. Merge Two Sorted Lists</title>
    <link href="http://salmons.info/2016/03/18/lc21/"/>
    <id>http://salmons.info/2016/03/18/lc21/</id>
    <published>2016-03-18T15:15:02.000Z</published>
    <updated>2019-01-31T07:00:35.880Z</updated>
    
    <content type="html"><![CDATA[<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br><a id="more"></a></p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>合并两个有序的链表</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>遍历</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">        struct ListNode* newHead= (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line"></span><br><span class="line">   struct ListNode* cur = newHead;</span><br><span class="line"></span><br><span class="line">    while(l1 &amp;&amp; l2) &#123;</span><br><span class="line">        if(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = l1 ? l1 : l2;</span><br><span class="line">    return newHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>234. Palindrome Linked List</title>
    <link href="http://salmons.info/2016/03/17/lc234/"/>
    <id>http://salmons.info/2016/03/17/lc234/</id>
    <published>2016-03-17T15:15:02.000Z</published>
    <updated>2019-01-30T08:04:01.462Z</updated>
    
    <content type="html"><![CDATA[<p>Given a singly linked list, determine if it is a palindrome.<br><a id="more"></a></p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>Could you do it in O(n) time and O(1) space?</p><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>判断链表是否是回文</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>快慢指针遍历找到中点，以中点为头反转后半部分，同时遍历前半部分和后半部分</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//辅助函数，反转链表</span><br><span class="line">struct ListNode* reverseList(struct ListNode* head) &#123;</span><br><span class="line">    if(head == NULL || head-&gt;next == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode *newHead = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    return newHead;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isPalindrome(struct ListNode* head) &#123;</span><br><span class="line">    </span><br><span class="line">    struct ListNode *slow, *fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">        </span><br><span class="line">    while(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    //slow is midst</span><br><span class="line">    struct ListNode *half = reverseList(slow);</span><br><span class="line">    </span><br><span class="line">    while(half)&#123;</span><br><span class="line">        if(half-&gt;val == head-&gt;val)&#123;</span><br><span class="line">            half = half-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a singly linked list, determine if it is a palindrome.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>328. Odd Even Linked List</title>
    <link href="http://salmons.info/2016/03/16/lc328/"/>
    <id>http://salmons.info/2016/03/16/lc328/</id>
    <published>2016-03-16T15:15:02.000Z</published>
    <updated>2019-01-30T07:55:10.007Z</updated>
    
    <content type="html"><![CDATA[<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.<br><a id="more"></a><br>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</span><br><span class="line">Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:</p><ul><li>The relative order inside both the even and odd groups should remain as it was in the input.</li><li>The first node is considered odd, the second node even and so on …</li></ul><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>链表排序，先奇数后偶数</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>两个指针分别代表奇偶的头，另外一个指针提前保存偶数的头，跨越式遍历，最后奇数尾节点接偶数的头</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* oddEvenList(struct ListNode* head) &#123;</span><br><span class="line">        if (head == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct ListNode* odd = head;</span><br><span class="line">    struct ListNode* even = head-&gt;next;</span><br><span class="line">    struct ListNode* evenHead = even;</span><br><span class="line">    </span><br><span class="line">    while(even != NULL &amp;&amp; even-&gt;next != NULL)&#123;</span><br><span class="line">        odd-&gt;next = even-&gt;next;</span><br><span class="line">        odd = odd-&gt;next;</span><br><span class="line">        even-&gt;next = odd-&gt;next;</span><br><span class="line">        even = even-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    odd-&gt;next = evenHead;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>203. Remove Linked List Elements</title>
    <link href="http://salmons.info/2016/03/15/lc203/"/>
    <id>http://salmons.info/2016/03/15/lc203/</id>
    <published>2016-03-15T15:15:02.000Z</published>
    <updated>2019-01-30T07:46:13.076Z</updated>
    
    <content type="html"><![CDATA[<p>Remove all elements from a linked list of integers that have value val.<br><a id="more"></a></p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>删除值为val的所有节点</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>可以用递归和迭代分别实现</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* removeElements(struct ListNode* head, int val) &#123;</span><br><span class="line">    if (head == NULL) &#123;</span><br><span class="line">    return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    struct ListNode *cur = head;</span><br><span class="line">    </span><br><span class="line">    while (cur-&gt;next) &#123;</span><br><span class="line">        if (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* removeElements(struct ListNode* head, int val) &#123;</span><br><span class="line">    if (head == NULL) &#123;return NULL;&#125;</span><br><span class="line">    </span><br><span class="line">    head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">    return head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Remove all elements from a linked list of integers that have value val.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>206. Reverse Linked List</title>
    <link href="http://salmons.info/2016/03/14/lc206/"/>
    <id>http://salmons.info/2016/03/14/lc206/</id>
    <published>2016-03-14T15:15:02.000Z</published>
    <updated>2019-01-30T07:37:44.122Z</updated>
    
    <content type="html"><![CDATA[<p>Reverse a singly linked list.<br><a id="more"></a></p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>反转链表</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>可以用递归和迭代分别实现</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* reverseList(struct ListNode* head) &#123;</span><br><span class="line">    struct ListNode *prev = NULL;</span><br><span class="line">    struct ListNode *curr = head;</span><br><span class="line">   </span><br><span class="line">    while(curr!= NULL)&#123;</span><br><span class="line">       struct ListNode *temp = curr-&gt;next;</span><br><span class="line">       curr-&gt;next = prev;</span><br><span class="line">       prev = curr;</span><br><span class="line">       curr = temp; </span><br><span class="line">    &#125;</span><br><span class="line">    return prev; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* reverseList(struct ListNode* head) &#123;</span><br><span class="line">    if (!head || !head-&gt;next) return head;</span><br><span class="line">    struct ListNode *newHead = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Reverse a singly linked list.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>19. Remove Nth Node From End of List</title>
    <link href="http://salmons.info/2016/03/13/lc19/"/>
    <id>http://salmons.info/2016/03/13/lc19/</id>
    <published>2016-03-13T15:15:02.000Z</published>
    <updated>2019-01-29T06:43:12.199Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, remove the n-th node from the end of list and return its head.<br><a id="more"></a></p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>Given n will always be valid.</p><p><strong>Follow up:</strong></p><p>Could you do this in one pass?</p><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先 p1 和 p2 都指向 head，然后 p2 向前走 n 步，这样 p1 和 p2 之间就间隔 n 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123;</span><br><span class="line">    </span><br><span class="line">    if (!head) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    struct ListNode *p = head;</span><br><span class="line">    struct ListNode *q = head;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    for(i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (q == NULL) &#123;</span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(q-&gt;next != NULL)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">    free(q);</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a linked list, remove the n-th node from the end of list and return its head.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>160. Intersection of Two Linked Lists</title>
    <link href="http://salmons.info/2016/03/12/lc160/"/>
    <id>http://salmons.info/2016/03/12/lc160/</id>
    <published>2016-03-12T15:15:02.000Z</published>
    <updated>2019-01-29T06:35:04.551Z</updated>
    
    <content type="html"><![CDATA[<p>Write a program to find the node at which the intersection of two singly linked lists begins.<br><a id="more"></a><br>For example, the following two linked lists:<br><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt=""><br>begin to intersect at node c1.</p><p>Example:<br><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">Output: Reference of the node with value = 8</span><br><span class="line">Input Explanation: The intersected node&apos;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br></pre></td></tr></table></figure><p>Notes:</p><ul><li>If the two linked lists have no intersection at all, return null.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>两链表相交的第一个公共节点</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>两个链表的长度分别为l1,l2; 将较长的链表指针向后移动 l1 - l2 绝对值长度，然后开始同时遍历两个链表，知道两个指针相等，就是相交的第一个点</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int linkedListLength(struct ListNode *head) &#123;</span><br><span class="line">    </span><br><span class="line">    int length = 0;</span><br><span class="line">    </span><br><span class="line">    while(head != NULL)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123;</span><br><span class="line">    </span><br><span class="line">    int l1 = linkedListLength(headA);</span><br><span class="line">    int l2 = linkedListLength(headB); </span><br><span class="line"></span><br><span class="line">    struct ListNode *a = headA;</span><br><span class="line">    struct ListNode *b = headB;</span><br><span class="line"></span><br><span class="line">    if (l1 &gt; l2) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(i = 0; i &lt; l1 - l2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">       int i = 0;</span><br><span class="line">        for(i = 0; i &lt; l2 - l1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(a != b)&#123;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>142. Linked List Cycle II</title>
    <link href="http://salmons.info/2016/03/11/lc142/"/>
    <id>http://salmons.info/2016/03/11/lc142/</id>
    <published>2016-03-11T15:15:02.000Z</published>
    <updated>2019-01-29T06:10:07.891Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.<br><a id="more"></a><br>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p><p>Note: Do not modify the linked list.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: tail connects to node index 0</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>找到链表开始入环的第一个节点</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>按照 first 一步，second 两步，发现 first 和 second 重合，确定了单向链表有环路了。让first回到链表的头部，重新走，second不是走2了，而是走1，那么当 first 和 second 再次相遇的时候，就是环路的入口了。</p><p>假定起点到环入口点的距离为 a，first 和 second 的相交点X与环入口点的距离为b，环路的周长为c，当 first 和 second 第一次相遇的时候，假定 first 走了 n 步。那么有：</p><p>first走的路径： a+b ＝ n；<br>second走的路径： a+b+k<em>c = 2</em>n； second 比 first 多走了k圈环路，总路程是first的2倍</p><p>根据上面可以得到 k*c=a+b=n显然，如果从相遇点X开始，second 再走 n 步的话，还可以再回到相遇点，同时first从头开始走的话，经过n步，也会达到相遇点X。</p><p>显然在这个步骤当中 first 和 second 只有前 a 步走的路径不同，所以当 first 和 second 再次重合的时候，必然是在链表的环路入口点上。</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode *detectCycle(struct ListNode *head) &#123;</span><br><span class="line">    if (head == NULL) return NULL;</span><br><span class="line">    </span><br><span class="line">    struct ListNode* firstp = head;</span><br><span class="line">    struct ListNode* secondp = head;</span><br><span class="line">    bool isCycle = false;</span><br><span class="line">    </span><br><span class="line">    while(secondp-&gt;next != NULL &amp;&amp; secondp-&gt;next-&gt;next != NULL) &#123;</span><br><span class="line">        firstp = firstp-&gt;next;</span><br><span class="line">        secondp = secondp-&gt;next-&gt;next;</span><br><span class="line">        if (firstp == secondp) &#123; isCycle = true; break; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(!isCycle) return NULL;</span><br><span class="line">    firstp = head;</span><br><span class="line">    while( firstp != secondp) &#123;</span><br><span class="line">        firstp = firstp-&gt;next;</span><br><span class="line">        secondp = secondp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return firstp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a linked list, return the node where the cycle begins. If there is no cycle, return null.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>141. Linked List Cycle</title>
    <link href="http://salmons.info/2016/03/10/lc141/"/>
    <id>http://salmons.info/2016/03/10/lc141/</id>
    <published>2016-03-10T15:15:02.000Z</published>
    <updated>2019-01-29T03:29:09.320Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, determine if it has a cycle in it.<br><a id="more"></a><br>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>判断链表是否有环</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>快慢指针遍历</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool hasCycle(struct ListNode *head) &#123;</span><br><span class="line">    </span><br><span class="line">    if (head == NULL) return false;</span><br><span class="line">    </span><br><span class="line">    struct ListNode* firstp = head;</span><br><span class="line">    struct ListNode* secondp = head;</span><br><span class="line">    </span><br><span class="line">    while(secondp-&gt;next != NULL &amp;&amp; secondp-&gt;next-&gt;next != NULL) &#123;</span><br><span class="line">        firstp = firstp-&gt;next;</span><br><span class="line">        secondp = secondp-&gt;next-&gt;next;</span><br><span class="line">        if (firstp == secondp) &#123; return true; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)</p><p>空间复杂度：O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>707. Design Linked List</title>
    <link href="http://salmons.info/2016/03/09/lc707/"/>
    <id>http://salmons.info/2016/03/09/lc707/</id>
    <published>2016-03-09T15:15:02.000Z</published>
    <updated>2019-01-29T02:33:46.336Z</updated>
    
    <content type="html"><![CDATA[<p>Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should<br><a id="more"></a><br>have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p><p>Implement these functions in your linked list class:</p><ul><li>get(index) : Get the value of the index-th node in the linked list. If the index is invalid, return -1.</li><li>addAtHead(val) : Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li><li>addAtTail(val) : Append a node of value val to the last element of the linked list.</li><li>addAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</li><li>deleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid.</li></ul><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyLinkedList linkedList = new MyLinkedList();</span><br><span class="line">linkedList.addAtHead(1);</span><br><span class="line">linkedList.addAtTail(3);</span><br><span class="line">linkedList.addAtIndex(1, 2);  // linked list becomes 1-&gt;2-&gt;3</span><br><span class="line">linkedList.get(1);            // returns 2</span><br><span class="line">linkedList.deleteAtIndex(1);  // now the linked list is 1-&gt;3</span><br><span class="line">linkedList.get(1);            // returns 3</span><br></pre></td></tr></table></figure><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>设计链表的几种基本操作</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>下文代码含有头指针。</p><h4 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">typedef struct node&#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct node *next;</span><br><span class="line">&#125; MyLinkedList;</span><br><span class="line"></span><br><span class="line">MyLinkedList* myLinkedListCreate()</span><br><span class="line">&#123;</span><br><span class="line">    MyLinkedList *head = (MyLinkedList *)malloc(sizeof(MyLinkedList));</span><br><span class="line">    head-&gt;val = 0;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line">    </span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printLinkedList(MyLinkedList *obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj == NULL || obj-&gt;next == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    MyLinkedList *cur = obj-&gt;next;</span><br><span class="line">    while (cur) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, cur-&gt;val);</span><br><span class="line">        printf(&quot;-&gt;&quot;);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int myLinkedListGet(MyLinkedList* obj, int index)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj == NULL || obj-&gt;next == NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    MyLinkedList* cur = obj-&gt;next;</span><br><span class="line">    while (cur != NULL) &#123;</span><br><span class="line">        if (i == index) &#123;</span><br><span class="line">            return cur-&gt;val;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            i++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myLinkedListAddAtHead(MyLinkedList* obj, int val)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyLinkedList* node = (MyLinkedList *)malloc(sizeof(MyLinkedList));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;next = obj-&gt;next;</span><br><span class="line">    obj-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myLinkedListAddAtTail(MyLinkedList* obj, int val)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyLinkedList* node = (MyLinkedList *)malloc(sizeof(MyLinkedList));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;next = NULL;</span><br><span class="line">    </span><br><span class="line">    if (obj-&gt;next == NULL) &#123;</span><br><span class="line">        obj-&gt;next = node;</span><br><span class="line">    &#125; else  &#123;</span><br><span class="line">        MyLinkedList* cur = obj-&gt;next;</span><br><span class="line">        while (cur-&gt;next != NULL) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    </span><br><span class="line">    if (obj == NULL || index &lt; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyLinkedList* node = (MyLinkedList *)malloc(sizeof(MyLinkedList));</span><br><span class="line">    if (index == 0) &#123;</span><br><span class="line">        node-&gt;val = val;</span><br><span class="line">        node-&gt;next = obj-&gt;next;</span><br><span class="line">        obj-&gt;next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        MyLinkedList* pre = obj;</span><br><span class="line">        MyLinkedList* cur = obj-&gt;next;</span><br><span class="line">        i=0;</span><br><span class="line">        while (i &lt; index &amp;&amp; cur != 0) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i == index) &#123;</span><br><span class="line">            node-&gt;val = val;</span><br><span class="line">            node-&gt;next = cur;</span><br><span class="line">            pre-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index)</span><br><span class="line">&#123;</span><br><span class="line">    MyLinkedList* tmp;</span><br><span class="line">    int i = 0;</span><br><span class="line">    </span><br><span class="line">    if (obj == NULL || obj-&gt;next == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (index == 0) &#123;</span><br><span class="line">        tmp = obj-&gt;next;</span><br><span class="line">        obj-&gt;next = tmp-&gt;next;</span><br><span class="line">        free(tmp);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        MyLinkedList* pre = obj;</span><br><span class="line">        MyLinkedList* cur = obj-&gt;next;</span><br><span class="line">        while (i &lt; index &amp;&amp; cur != 0) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i == index &amp;&amp; cur != 0) &#123;</span><br><span class="line">            tmp = cur;</span><br><span class="line">            pre-&gt;next = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myLinkedListFree(MyLinkedList* obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyLinkedList* cur = obj-&gt;next;</span><br><span class="line">    while(cur != 0) &#123;</span><br><span class="line">        obj-&gt;next = cur-&gt;next;</span><br><span class="line">        free(cur);</span><br><span class="line">        cur = obj-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    free(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://salmons.info/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://salmons.info/tags/LeetCode/"/>
    
      <category term="LinkedList" scheme="http://salmons.info/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>理解OC运行时</title>
    <link href="http://salmons.info/2016/03/08/Objective-C%20Runtime/"/>
    <id>http://salmons.info/2016/03/08/Objective-C Runtime/</id>
    <published>2016-03-08T05:37:09.000Z</published>
    <updated>2018-12-17T05:58:42.304Z</updated>
    
    <content type="html"><![CDATA[<p>一直对runtime很感兴趣，我猜是因为我是从<code>C</code>转过来的，有一定的情结！很多内容都是在我看这两本书的时候<br><a id="more"></a><br>学到的，在这里做一下总结和心得😁。</p><blockquote></blockquote><p><strong>《Objective-C高级编程 iOS与OS X多线程和内存管理》</strong> </p><blockquote></blockquote><p><strong>《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》</strong></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Objective-C</code>是基于<code>C</code>语言加入了面向对象特性和消息转发机制的动态语言，这意味着它不仅需要一个编译器，还需要Runtime系统来动态创建类和对象，进行消息发送和转发。</p><p><code>Runtime</code>又叫运行时，是一套底层的<code>C</code> 语言 API，是 <code>iOS</code> 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。</p><p><code>C</code>语言中，在<strong>编译期</strong>，函数的调用就会决定调用哪个函数。<br>而<code>OC</code>的函数，属于动态调用过程，在<strong>编译期</strong>并不能决定真正调用哪个函数，只有在真正<strong>运行时</strong>才会根据函数的名称找到对应的函数来调用。</p><p>在<code>Objective-C</code>中，使用<code>[receiver message]</code>语法并不会马上执行<code>receiver</code>对象的<code>message</code>方法的代码，而是向<code>receiver</code>发送一条<code>message</code>消息，这条消息可能由<code>receiver</code>来处理，也可能由转发给其他对象来处理，也有可能假装没有接收到这条消息而没有处理。其实<code>[receiver message]</code>被编译器转化为:</p><p><code>id objc_msgSend ( id self, SEL op, ... );</code></p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><h4 id="NSObject、id"><a href="#NSObject、id" class="headerlink" title="NSObject、id"></a>NSObject、id</h4><p>每当你<code>coding</code>的时候，有没有发现你创建的所有的类到最后都是以<code>NSObject</code>为基类，不相信的话就按住<code>command</code>键，一步一步的点，点到不能点！（<code>NSProxy</code>几个特殊的除外），然后我们来了解一下<code>NSObject</code>。</p><p><code>Apple</code>维护的一份运行时源码: <a href="http://opensource.apple.com//source/objc4/objc4-680/" target="_blank"><font color="blue"><u>objc4-680</u></font></a></p><p>为了方便，我把源码都贴在一起了，看几个结构体的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">//objc_object这是我们常用的id类型，指向的类型不局限于NSObject，譬如NSProxy</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">//NSObject * 就是 NSObject类型的指针了，它范围较小。</span><br><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface Object &#123; </span><br><span class="line">    Class isa; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line"> //你会发现isa_t是个union</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125; *id;</span><br><span class="line"></span><br><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见<code>struct objc_class : objc_object</code> <code>objc_class</code>继承于<code>objc_object</code></p><p><code>objc_class</code>当然也会包含相同的<code>isa</code>结构体，<code>Class</code>是<code>objc_class`</code> typedef<code>过来的，又有着继承关系。所以</code>Class`本身也是个对象。</p><p><code>objc_class</code>中其他成员：看名字理解，父类<code>superclass</code>，方法缓存<code>cache</code>，最后一个不容易看，我先说下是当前类的实例方法的一个集合。</p><h4 id="isa"><a href="#isa" class="headerlink" title="isa"></a>isa</h4><p>先说 <code>isa</code>表示一个<code>Class</code>对象的<code>Class</code>，也就是<code>Meta Class</code>。在面向对象设计中，一切都是对象，<code>Class</code>在设计中本身也是一个对象。</p><p>当一个对象的实例方法被调用的时候，就是通过<code>isa</code>找到相应的类，然后在该类的<code>class_data_bits_t</code>（上文中<code>objc_class</code>的成员）中去查找方法。<code>class_data_bits_t</code>是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。</p><p>如果是类方法呢？当然也是通过<code>isa</code>了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`对象的实例方法` —— &gt;  `isa` —— &gt; `对象所属类`</span><br><span class="line"></span><br><span class="line">`类方法` —— &gt; `isa` —— &gt; `❓`</span><br></pre></td></tr></table></figure><p>上面说了类也是个对象。那就让<code>isa</code>在类对象所属的类中找。我们叫它猿类，不好意思打错了，元类<code>Meta Class</code>。</p><p>下图很好解释了对象，类，元类之间的关系。 </p><p><img src="http://oma38gsun.bkt.clouddn.com/meta-class.jpg" alt=""></p><p>解释一下这个图： 实线是<code>super_class</code>指针，虚线是<code>isa</code>指针。</p><ul><li><code>Root Class</code>是<code>NSObject</code>， <code>NSObject</code>是没有超类的，所以<code>Root class(class)</code>的<code>superclass</code>指向<code>nil</code>。</li><li>每个<code>Class</code>都有一个<code>isa</code>指针指向唯一的<code>Meta class</code></li><li><code>Root class(meta)</code>的<code>superclass</code>指向<code>Root class(class)</code>，也就是<code>NSObject</code>，形成一个回路。</li><li>每个<code>Meta class</code>的<code>isa</code>指针都指向<code>Root class (meta)</code>。</li></ul><p><code>isa</code>的类型是<code>isa_t</code>。 源码<code>isa_t</code>是个联合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于<code>isa_t</code>的深入了解，我也不是很懂！抱歉哈🐶</strong></p><p>懂了上图和元类的概念就可以了。</p><h4 id="隐藏参数self和-cmd"><a href="#隐藏参数self和-cmd" class="headerlink" title="隐藏参数self和_cmd"></a>隐藏参数self和_cmd</h4><p>当<code>[receiver message]</code>调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数<code>self</code>和<code>_cmd</code>，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。至于对于<code>self</code>的描述，上面已经解释非常清楚了，下面我们重点讲解<code>_cmd</code>。</p><p><code>_cmd</code>表示当前调用方法，其实它就是一个方法选择器<code>SEL</code>（<em>下文提到</em>）。一般用于判断方法名或在<code>Associated Objects</code>中唯一标识键名，后面在<code>Associated Objects</code>会讲到。</p><h4 id="self-和-super"><a href="#self-和-super" class="headerlink" title="self 和 super"></a>self 和 super</h4><p><code>self</code>表示当前这个类的对象，而<code>super</code>是一个编译器标示符，和<code>self</code>指向同一个消息接受者。</p><p>譬如<code>[self class]</code>和<code>[super class]</code>，接受消息者都是当前这个类的对象，但<code>super</code>与<code>self</code>不同的是，<code>self</code>调用<code>class</code>方法时，是在子类中查找方法，而<code>super</code>调用<code>class</code>方法时，是在父类中查找方法。</p><p>又譬如当调用<code>[self class]</code>方法时，会转化为<code>objc_msgSend</code>函数，这个函数定义如下：</p><p><code>id objc_msgSend(id self, SEL op, ...)</code></p><p>这时会从当前类的方法列表中查找，如果没有，就到父类查找，还是没有，最后在<code>NSObject</code>类查找到。我们可以从<code>NSObject.m</code>文件中看到<code>- (Class)class</code>的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又譬如当调用<code>[super class]</code>方法时，会转化为<code>objc_msgSendSuper</code>，这个函数定义如下：</p><p><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</code></p><p><code>objc_msgSendSuper</code>函数第一个参数<code>super</code>的数据类型是一个指向<code>objc_super</code>的结构体，从<code>message.h</code>文件中查看它的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/// Specifies the superclass of an instance. </span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    /// Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line"></span><br><span class="line">    /// Specifies the particular superclass of the instance to message. </span><br><span class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br><span class="line">    /* For compatibility with old objc-runtime.h header */</span><br><span class="line">    __unsafe_unretained Class class;</span><br><span class="line">#else</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">#endif</span><br><span class="line">    /* super_class is the first class to search */</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>结构体包含两个成员，第一个是<code>receiver</code>，表示某个类的实例。第二个是<code>super_class</code>表示当前类的父类。</p><p>这时首先会构造出<code>objc_super</code>结构体，这个结构体第一个成员是<code>self</code>，第二个成员是<code>(id)class_getSuperclass(objc_getClass(&quot;Class&quot;))</code>，实际上该函数会输出<code>SuperClass</code>。然后在父类查找<code>class</code>方法，查找不到，最后在<code>NSObject</code>查到。此时，内部使用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，与<code>[self class]</code>调用相同，所以结果还是当前类。</p><h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p><code>Ivar</code>表示类中的实例变量，在<code>runtime.h</code>文件中找到它的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents an instance variable.</span><br><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line">struct objc_ivar &#123;</span><br><span class="line">    char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Ivar</code>其实就是一个指向<code>objc_ivar</code>结构体指针，它包含了变量名<code>(ivar_name)</code>、变量类型<code>(ivar_type)</code>等信息。</p><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p><code>SEL</code>称方法选择器</p><p>通俗话来讲，<code>isa</code>指针指向的类的结构体中有这样一张<code>SEL</code>和<code>IMP</code>对应 的Dispatch table。你找到了SEL，最后还是要通过这个table找到IMP。<code>SEL</code>只是一个方法编号，并不是真正的方法实现地址。</p><p><code>SEL</code>要说的一点是，如果类不同，但是有相同的方法，他们对应的方法选择器是相同的，即使参数的类型不同，他们对应的方法选择器也是相同的，所以<code>Objective-C</code>不支持函数重载，有关什么是函数重载可以了解下<code>C++</code></p><p>接受者<code>receiver</code>收到对应的<code>selector</code>，如果有不能执行这个方法的情况，这条<code>message</code>要被转发，或者利用<code>runtime</code>动态添加这个方法的实现来正常执行。如果正常执行或者转发都失败。程序会<code>crash</code></p><p>所以<code>OC</code>这门运行时语言在<strong>编译期</strong>只确定了发消息，接受者如何响应或者处理消息是在<strong>运行时</strong><code>runtime</code>决定，所以和<code>C</code>语言不同，不声明方法，程序编译也不会报错。</p><h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p><code>IMP</code>本质上就是一个函数指针，指向方法的实现，在<code>objc.h</code>找到它的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// A pointer to the function of a method implementation. </span><br><span class="line">#if !OBJC_OLD_DISPATCH_PROTOTYPES</span><br><span class="line">typedef void (*IMP)(void /* id, SEL, ... */ ); </span><br><span class="line">#else</span><br><span class="line">typedef id (*IMP)(id, SEL, ...); </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>当你向某个对象发送一条信息，可以由这个函数指针来指定方法的实现，它最终就会执行那段代码，这样可以绕开消息传递阶段而去执行另一个方法实现。</p><p>说句大白话，拿到了<code>IMP</code>，才能像使用<code>C</code>语言函数指针一样肆无忌惮。</p><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p><code>Method</code>表示类中的某个方法，在runtime.h文件中找到它的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method in a class definition.</span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实<code>Method</code>就是一个指向<code>objc_method</code>结构体指针，它存储了方法名<code>(method_name)</code>、方法类型<code>(method_types)</code>和方法实现<code>(method_imp)</code>等信息。</p><p>大白话就是：<code>Method</code>表示一种类型，这种类型与<code>SEL</code>和实现<code>IMP</code>相关。</p><h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p><code>Cache</code>主要用来缓存，那它缓存什么呢？我们先在<code>runtime.h</code>文件看看它的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_cache *Cache                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">struct objc_cache &#123;</span><br><span class="line">    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;</span><br><span class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[1]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Cache</code>其实就是一个存储<code>Method</code>的链表，主要是为了优化方法调用的性能。当对象<code>receiver</code>调用方法<code>message</code>时，首先根据对象<code>receiver</code>的isa指针查找到它对应的类，然后在类的<code>methodLists</code>中搜索方法，如果没有找到，就使用<code>super_class</code>指针到父类中的<code>methodLists</code>查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用<code>Cache</code>来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到<code>methodLists</code>查找。</p><p>关于 <code>SEL</code>, <code>IMP</code>, <code>Method</code>的理解，理解的不好的话，可以看看这篇文章<a href="http://blog.csdn.net/fengsh998/article/details/8614486" target="_blank" rel="noopener">http://blog.csdn.net/fengsh998/article/details/8614486</a></p><h3 id="Runtime原理"><a href="#Runtime原理" class="headerlink" title="Runtime原理"></a>Runtime原理</h3><h4 id="objc-msgSend函数是如何发送消息的"><a href="#objc-msgSend函数是如何发送消息的" class="headerlink" title="objc_msgSend函数是如何发送消息的"></a>objc_msgSend函数是如何发送消息的</h4><ul><li>首先根据<code>receiver</code>对象的<code>isa</code>指针获取它对应的<code>class</code></li><li>优先在<code>class</code>的<code>cache</code>查找<code>message方</code>法，如果找不到，再到<code>methodLists</code>查找</li><li>如果没有在<code>class</code>找到，再到<code>super_class</code>查找</li><li>一旦找到<code>message</code>这个方法，就执行它实现的<code>IMP</code>。缓存到<code>cache</code>里面，以便下次使用</li></ul><h4 id="消息发送和转发"><a href="#消息发送和转发" class="headerlink" title="消息发送和转发"></a>消息发送和转发</h4><p><code>[receiver message]</code>调用方法时，如果在<code>message</code>方法在<code>receiver</code>对象的类继承体系中没有找到方法，那怎么办？一般情况下，程序在运行时就会Crash掉，抛出 <code>unrecognized selector sent to …</code>类似这样的异常信息。但在抛出异常之前，还有三次机会按以下顺序让你拯救程序。</p><h5 id="Method-Resolution"><a href="#Method-Resolution" class="headerlink" title="Method Resolution"></a>Method Resolution</h5><p>首先<code>OC</code>在运行时调用<code>+ resolveInstanceMethod:</code>或<code>+ resolveClassMethod:</code>方法，让你添加方法的实现。如果你添加方法并返回YES，那系统在运行时就会重新启动一次消息发送的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface Message : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage:(NSString *)word;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Message</span><br><span class="line"></span><br><span class="line">- (void)sendMessage:(NSString *)word</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;normal way : send message = %@&quot;, word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>如果我在<code>viewDidLoad</code>方法中创建<code>Message</code>对象并调用<code>sendMessage</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    Message *message = [Message new];</span><br><span class="line">    [message sendMessage:@&quot;SwifterFit&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：send message = SwifterFit</p><p>但现在我将原来<code>sendMessage</code>方法实现给注释掉，覆盖<code>resolveInstanceMethod</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Method Resolution</span><br><span class="line"></span><br><span class="line">/// override resolveInstanceMethod or resolveClassMethod for changing sendMessage method implementation</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    if (sel == @selector(sendMessage:)) &#123;</span><br><span class="line">        class_addMethod([self class], sel, imp_implementationWithBlock(^(id self, NSString *word) &#123;</span><br><span class="line">            NSLog(@&quot;method resolution way : send message = %@&quot;, word);</span><br><span class="line">        &#125;), &quot;v@*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：send message = SwifterFit</p><p>如果<code>resolveInstanceMethod</code>方法返回<code>NO</code>，运行时就跳转到下一步：消息转发<code>Message Forwarding</code></p><h5 id="Fast-Forwarding"><a href="#Fast-Forwarding" class="headerlink" title="Fast Forwarding"></a>Fast Forwarding</h5><p>如果目标对象实现<code>- forwardingTargetForSelector:</code>方法，系统就会在运行时调用这个方法，只要这个方法返回的不是<code>nil</code>或<code>self</code>，也会重启消息发送的过程，把这消息转发给其他对象来处理。否则，就会继续<code>Normal Fowarding</code>。</p><p>继续上面<code>Message</code>类的例子，将<code>sendMessage</code>和<code>resolveInstanceMethod</code>方法注释掉，然后添加<code>forwardingTargetForSelector</code>方法的实现：</p><p>将<code>sendMessage</code>和<code>resolveInstanceMethod</code>方法注释掉，然后添加<code>forwardingTargetForSelector</code>方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Fast Forwarding</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    if (aSelector == @selector(sendMessage:)) &#123;</span><br><span class="line">        return [MessageForwarding new];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时还缺一个转发消息的类<code>MessageForwarding</code>，这个类的设计与实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface MessageForwarding : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage:(NSString *)word;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation MessageForwarding</span><br><span class="line"></span><br><span class="line">- (void)sendMessage:(NSString *)word</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;fast forwarding way : send message = %@&quot;, word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这里叫<code>Fast</code>，是因为这一步不会创建<code>NSInvocation</code>对象，但<code>Normal Forwarding</code>会创建它，所以相对于更快点。</p><h5 id="Normal-Forwarding"><a href="#Normal-Forwarding" class="headerlink" title="Normal Forwarding"></a>Normal Forwarding</h5><p>如果没有使用<code>Fast Forwarding</code>来消息转发，最后只有使用<code>Normal Forwarding</code>来进行消息转发。它首先调用<code>methodSignatureForSelector:</code>方法来获取函数的参数和返回值，如果返回为<code>nil</code>，程序会Crash掉，并抛出<code>unrecognized selector sent to instance</code>异常信息。如果返回一个函数签名，系统就会创建一个<code>NSInvocation</code>对象并调用<code>-forwardInvocation:</code>方法。</p><p>继续前面的例子，将<code>forwardingTargetForSelector</code>方法注释掉，添加<code>methodSignatureForSelector和forwardInvocation</code>方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Normal Forwarding</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature *methodSignature = [super methodSignatureForSelector:aSelector];</span><br><span class="line"></span><br><span class="line">    if (!methodSignature) &#123;</span><br><span class="line">        methodSignature = [NSMethodSignature signatureWithObjCTypes:&quot;v@:*&quot;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return methodSignature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    MessageForwarding *messageForwarding = [MessageForwarding new];</span><br><span class="line"></span><br><span class="line">    if ([messageForwarding respondsToSelector:anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:messageForwarding];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runtime提供三种方式来将原来的方法实现代替掉，那该怎样选择它们呢？</p><ul><li><code>Method Resolution</code>：由于<code>Method Resolution</code>不能像消息转发那样可以交给其他对象来处理，所以只适用于在原来的类中代替掉。</li><li><code>Fast Forwarding</code>：它可以将消息处理转发给其他对象，使用范围更广，不只是限于原来的对象。</li><li><code>Normal Forwarding</code>：它跟<code>Fast Forwarding</code>一样可以消息转发，但它能通过<code>NSInvocation</code>对象获取更多消息发送的信息，例如：<code>target</code>、<code>selector</code>、<code>arguments</code>和返回值等信息。</li></ul><h3 id="Runtime应用"><a href="#Runtime应用" class="headerlink" title="Runtime应用"></a>Runtime应用</h3><h4 id="为Category添加属性property"><a href="#为Category添加属性property" class="headerlink" title="为Category添加属性property"></a>为Category添加属性property</h4><ul><li><code>Associated Objects</code></li></ul><p>当想使用<code>Category</code>对已存在的类进行扩展时，一般只能添加实例方法或类方法，而不适合添加额外的属性。虽然可以在<code>Category</code>头文件中声明<code>property</code>属性，但在实现文件中编译器是无法<code>synthesize</code>任何实例变量和属性访问方法。这时需要自定义属性访问方法并且使用<code>Associated Objects</code>来给已存在的类<code>Category</code>添加自定义的属性。<code>Associated Objects</code>提供三个API来向对象添加、获取和删除关联值：</p><p><code>void objc_setAssociatedObject (id object, const void *key, id value, objc_AssociationPolicy policy )</code><br><code>id objc_getAssociatedObject (id object, const void *key )</code><br><code>void objc_removeAssociatedObjects (id object )</code></p><p>其中<code>objc_AssociationPolicy</code>是个枚举类型，它可以指定Objc内存管理的引用计数机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. </span><br><span class="line">                                            *   The association is not made atomically. */</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied. </span><br><span class="line">                                            *   The association is not made atomically. */</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</span><br><span class="line">                                            *   The association is made atomically. */</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</span><br><span class="line">                                            *   The association is made atomically. */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面有个关于<code>NSObject+AssociatedObject</code> Category添加属性<code>associatedObject</code>的示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (AssociatedObject)</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) id associatedObject;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (AssociatedObject)</span><br><span class="line"></span><br><span class="line">- (void)setAssociatedObject:(id)associatedObject</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)associatedObject</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>Associated Objects</code>的key要求是唯一并且是常量，而<code>SEL</code>是满足这个要求的，所以上面的采用隐藏参数<code>_cmd</code>作为key。</p><h4 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h4><p>提到<code>Objective-C</code> 中的 <code>Runtime</code>，大多数人第一个想到的可能就是黑魔法<code>Method Swizzling</code>。毕竟这是<code>Runtime</code>里面很强大的一部分，它可以通过<code>Runtime</code>的API实现更改任意的方法，理论上可以在运行时通过类名/方法名<code>hook</code>到任何 <code>OC</code>方法，替换任何类的实现以及新增任意类。</p><p>举的最多的例子应该就是埋点统计用户信息的例子。</p><p>假设我们需要在页面上不同的地方统计用户信息，常见做法有两种：</p><ul><li>傻瓜式的在所有需要统计的页面都加上代码。这样做简单，但是重复的代码太多。</li><li>把统计的代码写入基类中，比如说<code>BaseViewController</code>。这样虽然代码只需要写一次，但是<code>UITableViewController</code>，<code>UICollectionViewcontroller</code>都需要写一遍，这样重复的代码依旧不少。</li></ul><p>这时候我们就可以使用 <code>Method Swizzling</code>。</p><p><code>Method Swizzing</code>是发生在<strong>运行时</strong>的，主要用于在<strong>运行时</strong>将两个<code>Method</code>进行交换，我们可以将<code>Method Swizzling</code>代码写到任何地方，但是只有在这段<code>Method Swilzzling</code>代码执行完毕之后互换才起作用。而且<code>Method Swizzling</code>也是<code>iOS</code>中<code>AOP</code>(Aspect-Oriented Programming)(<em>面相方面编程</em>)的一种实现方式，我们可以利用苹果这一特性来实现<code>AOP</code>编程。</p><p><code>Method Swizzling</code>本质上就是对<code>IMP</code>和<code>SEL</code>进行交换。</p><p>一般我们使用都是新建一个分类，在分类中进行<code>Method Swizzling</code>方法的交换。交换的代码模板如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">@implementation UIViewController (Swizzling)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = [self class];</span><br><span class="line">        // When swizzling a class method, use the following:</span><br><span class="line">        // Class class = object_getClass((id)self);</span><br><span class="line">        SEL originalSelector = @selector(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">        BOOL didAddMethod = class_addMethod(class,</span><br><span class="line">                                            originalSelector,</span><br><span class="line">                                            method_getImplementation(swizzledMethod),</span><br><span class="line">                                            method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        if (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(class,</span><br><span class="line">                                swizzledSelector,</span><br><span class="line">                                method_getImplementation(originalMethod),</span><br><span class="line">                                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - Method Swizzling</span><br><span class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [self xxx_viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>Method Swizzling</code>可以在运行时通过修改类的方法列表中<code>selector</code>对应的函数或者设置交换方法实现，来动态修改方法。可以重写某个方法而不用继承，同时还可以调用原先的实现。所以通常应用于在<code>category</code>中添加一个方法。</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><h5 id="Swizzling应该总在-load中执行"><a href="#Swizzling应该总在-load中执行" class="headerlink" title="Swizzling应该总在+load中执行"></a><code>Swizzling</code>应该总在<code>+load</code>中执行</h5><p><code>Objective-C</code>在运行时会自动调用类的两个方法<code>+load</code>和<code>+initialize</code>。<code>+load</code>会在类初始加载时调用， <code>+initialize</code>方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 <code>+initialize</code>方法是永远不会被调用的。所以<code>Swizzling</code>要是写在<code>+initialize</code>方法中，是有可能永远都不被执行。</p><p>和<code>+initialize</code>比较<code>+load</code>能保证在类的初始化过程中被加载。</p><h5 id="Swizzling应该总是在dispatch-once中执行"><a href="#Swizzling应该总是在dispatch-once中执行" class="headerlink" title="Swizzling应该总是在dispatch_once中执行"></a><code>Swizzling</code>应该总是在<code>dispatch_once</code>中执行</h5><p>Swizzling会改变全局状态，所以在运行时采取一些预防措施，使用<code>dispatch_once</code>就能够确保代码不管有多少线程都只被执行一次。这将成为<code>Method Swizzling</code>的最佳实践。</p><p>这里有一个很容易犯的错误，那就是继承中用了<code>Swizzling</code>。如果不写<code>dispatch_once</code>就会导致<code>Swizzling</code>失效！</p><p>举个例子，比如同时对<code>NSArray</code>和<code>NSMutableArray</code>中的<code>objectAtIndex:</code>方法都进行了<code>Swizzling</code>，这样可能会导致<code>NSArray</code>中的<code>Swizzling</code>失效的。</p><p>可是为什么会这样呢？</p><p>原因是，我们没有用<code>dispatch_once</code>控制<code>Swizzling</code>只执行一次。如果这段<code>Swizzling</code>被执行多次，经过多次的交换<code>IMP</code>和<code>SEL</code>之后，结果可能就是未交换之前的状态。</p><p>比如说父类A的B方法和子类C的D方法进行交换，交换一次后，父类A持有D方法的<code>IMP</code>，子类C持有B方法的<code>IMP</code>，但是再次交换一次，就又还原了。父类A还是持有B方法的<code>IMP</code>，子类C还是持有D方法的<code>IMP</code>，这样就相当于咩有交换。可以看出，如果不写<code>dispatch_once</code>，偶数次交换以后，相当于没有交换，<code>Swizzling</code>失效！</p><h5 id="Swizzling在-load中执行时，不要调用-super-load"><a href="#Swizzling在-load中执行时，不要调用-super-load" class="headerlink" title="Swizzling在+load中执行时，不要调用[super load]"></a><code>Swizzling</code>在<code>+load</code>中执行时，不要调用<code>[super load]</code></h5><p>原因同注意点二，如果是多继承，并且对同一个方法都进行了<code>Swizzling</code>，那么调用<code>[super load]</code>以后，父类的<code>Swizzling</code>就失效了。</p><p>现在比较火的<code>hotfix</code>，<code>JSPatch</code>就是应用了<code>OC</code>的<code>runtime</code>特性实现<code>js</code>与<code>OC</code>互通来动态修改方法的实现。</p><p>比较出名的以下是字典转模型的开眼框架都应用了<code>runtime</code>特性。</p><p><code>Apple</code>的<code>KVO</code> 也使用了<code>runtime</code>的特性。</p><blockquote><p><code>Method Swizzling</code>就像一把瑞士小刀，如果使用得当，它会有效地解决问题。但使用不当，将带来很多麻烦。在<code>stackoverflow</code>上有人已经提出这样一个问题：<a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="noopener">What are the Dangers of Method Swizzling in Objective C?</a>，它的危险性主要体现以下几个方面：</p></blockquote><blockquote><ul><li>Method swizzling is not atomic</li><li>Changes behavior of un-owned code</li><li>Possible naming conflicts</li><li>Swizzling changes the method’s arguments</li><li>The order of swizzles matters</li><li>Difficult to understand (looks recursive)</li><li>Difficult to debug</li></ul></blockquote><p><strong>继续努力吧。加油！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直对runtime很感兴趣，我猜是因为我是从&lt;code&gt;C&lt;/code&gt;转过来的，有一定的情结！很多内容都是在我看这两本书的时候&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://salmons.info/categories/iOS/"/>
    
    
  </entry>
  
</feed>
